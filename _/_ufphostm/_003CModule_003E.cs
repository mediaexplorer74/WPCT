// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: ufphostm, Version=10.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
// MVID: 665758C6-46E8-4456-A462-54EBEBC45DB9
// Assembly location: C:\Users\Admin\Desktop\d\ufphostm.dll

using \u003CCppImplementationDetails\u003E;
using \u003CCrtImplementationDetails\u003E;
using ATL;
using FlashingPlatform;
using Microsoft.Windows.Flashing.Platform;
using RAII;
using std;
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Threading;

internal class \u003CModule\u003E
{
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01CPLAODJH\u0040S\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01PLPBNMEI\u0040M\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01CKDDGHAB\u0040D\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01HMGJMAIH\u0040B\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03LAIAPFCB\u0040Val\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0M\u0040DBGDLGLL\u0040ForceRemove\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003F\u003F_C\u0040_08KAAPDIAN\u0040NoRemove\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003F\u003F_C\u0040_06JBKGCNBB\u0040Delete\u003F\u0024AA\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040J \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040J\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040JQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAPAG \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAPAG\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PAPAGQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAG \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAG\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PAGQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAM \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAM\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PAMQ3\u0040;
  internal static CAtlReleaseManagedClassFactories ATL\u002E_AtlReleaseManagedClassFactories;
  internal static __FnPtr<void ()> ATL\u002E\u003FA0xea60aed3\u002E_AtlReleaseManagedClassFactories\u0024initializer\u0024;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAN \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAN\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PANQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040_K \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040_K\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040_KQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040E \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040E\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040EQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PATtagCY\u0040\u0040 \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PATtagCY\u0040\u0040\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PATtagCY\u0040\u0040Q3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040G \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040G\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040GQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040K \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040K\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040KQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAF \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAF\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PAFQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAI \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAI\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PAIQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAJ \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAJ\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PAJQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAD \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAD\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PADQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAUIUnknown\u0040\u0040 \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAUIUnknown\u0040\u0040\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PAUIUnknown\u0040\u0040Q3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PA_K \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PA_K\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PA_KQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAPAUIUnknown\u0040\u0040 \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAPAUIUnknown\u0040\u0040\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PAPAUIUnknown\u0040\u0040Q3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040TtagCY\u0040\u0040 \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040TtagCY\u0040\u0040\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040TtagCY\u0040\u0040Q3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040M \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040M\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040MQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAPAUIDispatch\u0040\u0040 \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAPAUIDispatch\u0040\u0040\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PAPAUIDispatch\u0040\u0040Q3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAH \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAH\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PAHQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAUIDispatch\u0040\u0040 \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAUIDispatch\u0040\u0040\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PAUIDispatch\u0040\u0040Q3\u0040;
  internal static int __\u0040\u0040_PchSym_\u004000\u0040hwpgllohUuozhsrmtUfukslhgUnzmztvwUvcgvimzoUlyquivUrDIGUkxsOlyq\u0040ufphostm;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAK \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAK\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PAKQ3\u0040;
  internal static unsafe sbyte* ATL\u002E\u003FA0xea60aed3\u002EszValToken;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040I \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040I\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040IQ3\u0040;
  internal static unsafe sbyte* ATL\u002E\u003FA0xea60aed3\u002EszDelete;
  internal static bool \u003Fm_bInitFailed\u0040CAtlBaseModule\u0040ATL\u0040\u00402_NA;
  internal static unsafe _ATL_OBJMAP_ENTRY30* __pobjMapEntryLast;
  internal static unsafe sbyte* ATL\u002E\u003FA0xea60aed3\u002EszBinaryVal;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040F \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040F\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040FQ3\u0040;
  internal static unsafe _ATL_OBJMAP_ENTRY30* __pobjMapEntryFirst;
  internal static unsafe sbyte* ATL\u002E\u003FA0xea60aed3\u002EszForceRemove;
  internal static unsafe sbyte* ATL\u002E\u003FA0xea60aed3\u002EszStringVal;
  internal static unsafe sbyte* ATL\u002E\u003FA0xea60aed3\u002EmultiszStringVal;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040_J \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040_J\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040_JQ3\u0040;
  internal static unsafe sbyte* ATL\u002E\u003FA0xea60aed3\u002EszNoRemove;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PA_J \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PA_J\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PA_JQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040H \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040H\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040HQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040D \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040D\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040DQ3\u0040;
  internal static unsafe sbyte* ATL\u002E\u003FA0xea60aed3\u002EszDwordVal;
  internal static unsafe void* _pAtlReleaseManagedClassFactories;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040PAE \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040PAE\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040PAEQ3\u0040;
  internal static \u0024PTMType\u0024QQtagVARIANT\u0040\u0040N \u003FpmField\u0040\u003F\u0024CVarTypeInfo\u0040N\u0040ATL\u0040\u00402QQtagVARIANT\u0040\u0040NQ3\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024CAutoComFree\u0040PBG\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024CAutoCleanupBase\u0040PBG\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoComFree\u0040PBG\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoCleanupBase\u0040PBG\u0040RAII\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoCleanupBase\u0040PBG\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_34 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoCleanupBase\u0040PBG\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoComFree\u0040PBG\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_30 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoComFree\u0040PBG\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024CAutoComFree\u0040PBG\u0040RAII\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6GXXZ \u003F\u003F_7\u003F\u0024CAutoComFree\u0040PBG\u0040RAII\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1DC\u0040CMEHKPEC\u0040\u003F\u0024AAY\u003F\u0024AAo\u003F\u0024AAu\u003F\u0024AA\u003F5\u003F\u0024AAm\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAl\u003F\u0024AAl\u003F\u0024AA\u003F5\u003F\u0024AAM\u003F\u0024AAo\u003F\u0024AAv\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAt\u003F\u0024AA\u003F\u0024CI\u003F\u0024AA\u003F\u0024CJ\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1CM\u0040MEAAIPAK\u0040\u003F\u0024AAE\u003F\u0024AAn\u003F\u0024AAu\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AA\u003F5\u003F\u0024AAh\u003F\u0024AAa\u003F\u0024AAs\u003F\u0024AA\u003F5\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1FG\u0040NPJPCCED\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAa\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1DE\u0040GCEKIMOP\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAp\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAh\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1DA\u0040DIJJDJIP\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAw\u003F\u0024AA\u003F5\u003F\u0024AAd\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1DG\u0040KNJJMPJN\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAi\u003F\u0024AAv\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAw\u003F\u0024AA\u003F5\u003F\u0024AAd\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CB\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1EC\u0040LEPNEJDA\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAc\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAf\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAs\u003F\u0024AAh\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F5\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CD\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1EG\u0040CCFOHDEM\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAf\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAl\u003F\u0024AAy\u003F\u0024AA\u003F5\u003F\u0024AAn\u003F\u0024AAa\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BP\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1DO\u0040FGPACCJK\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAu\u003F\u0024AAn\u003F\u0024AAi\u003F\u0024AAq\u003F\u0024AAu\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAI\u003F\u0024AAD\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CD\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1EG\u0040FNHIMFAE\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAa\u003F\u0024AAl\u003F\u0024AA\u003F5\u003F\u0024AAn\u003F\u0024AAu\u003F\u0024AAm\u003F\u0024AAb\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1CI\u0040ECIEBNIH\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAw\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAW\u003F\u0024AAI\u003F\u0024AAM\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1DA\u0040FFAALIKO\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAs\u003F\u0024AAk\u003F\u0024AAi\u003F\u0024AAp\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAf\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1CC\u0040KCIGDDEL\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAb\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CC\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1EE\u0040BNENPODH\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F5\u003F\u0024AAm\u003F\u0024AAa\u003F\u0024AAs\u003F\u0024AAs\u003F\u0024AA\u003F5\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAm\u003F\u0024AAo\u003F\u0024AAd\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1DA\u0040MBNNDMOJ\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAb\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAm\u003F\u0024AAo\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1DC\u0040PGNKAIIP\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAf\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAs\u003F\u0024AAh\u003F\u0024AA\u003F5\u003F\u0024AAF\u003F\u0024AAF\u003F\u0024AAU\u003F\u0024AA\u003F5\u003F\u0024AAf\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024CAutoDelete\u0040PAVCGenericProgressShim\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024CAutoCleanupBase\u0040PAVCGenericProgressShim\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024CAutoRelease\u0040PAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024CAutoCleanupBase\u0040PAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024CAutoDeleteArray\u0040E\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024CAutoCleanupBase\u0040PAE\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024CAutoDeleteArray\u0040\u0024\u0024CBG\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024CAutoRelease\u0040PAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024CAutoCleanupBase\u0040PAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2CGenericProgressShim\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2IGenericProgress\u0040FlashingPlatform\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2CDeviceNotificationCallbackShim\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2IDeviceNotificationCallback\u0040FlashingPlatform\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoDelete\u0040PAVCGenericProgressShim\u0040\u0040\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoCleanupBase\u0040PAVCGenericProgressShim\u0040\u0040\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoRelease\u0040PAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoCleanupBase\u0040PAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoDeleteArray\u0040E\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoCleanupBase\u0040PAE\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoDeleteArray\u0040\u0024\u0024CBG\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoRelease\u0040PAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoCleanupBase\u0040PAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040CGenericProgressShim\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040IGenericProgress\u0040FlashingPlatform\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040CDeviceNotificationCallbackShim\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040IDeviceNotificationCallback\u0040FlashingPlatform\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoCleanupBase\u0040PAVCGenericProgressShim\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_56 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoCleanupBase\u0040PAVCGenericProgressShim\u0040\u0040\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoDelete\u0040PAVCGenericProgressShim\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_51 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoDelete\u0040PAVCGenericProgressShim\u0040\u0040\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoCleanupBase\u0040PAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_68 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoCleanupBase\u0040PAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoRelease\u0040PAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_64 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoRelease\u0040PAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoCleanupBase\u0040PAE\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_34 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoCleanupBase\u0040PAE\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoDeleteArray\u0040E\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_32 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoDeleteArray\u0040E\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoDeleteArray\u0040\u0024\u0024CBG\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_36 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoDeleteArray\u0040\u0024\u0024CBG\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoCleanupBase\u0040PAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_69 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoCleanupBase\u0040PAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoRelease\u0040PAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_65 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoRelease\u0040PAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3IGenericProgress\u0040FlashingPlatform\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_40 \u003F\u003F_R0\u003FAUIGenericProgress\u0040FlashingPlatform\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3CGenericProgressShim\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_27 \u003F\u003F_R0\u003FAVCGenericProgressShim\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3IDeviceNotificationCallback\u0040FlashingPlatform\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_51 \u003F\u003F_R0\u003FAUIDeviceNotificationCallback\u0040FlashingPlatform\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3CDeviceNotificationCallbackShim\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_38 \u003F\u003F_R0\u003FAVCDeviceNotificationCallbackShim\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024CAutoDelete\u0040PAVCGenericProgressShim\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024CAutoRelease\u0040PAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024CAutoDeleteArray\u0040E\u0040RAII\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024CAutoDeleteArray\u0040\u0024\u0024CBG\u0040RAII\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024CAutoRelease\u0040PAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4CGenericProgressShim\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4CDeviceNotificationCallbackShim\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6GXXZ \u003F\u003F_7\u003F\u0024CAutoRelease\u0040PAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040Q6GXXZ \u003F\u003F_7\u003F\u0024CAutoDeleteArray\u0040\u0024\u0024CBG\u0040RAII\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040Q6GXXZ \u003F\u003F_7\u003F\u0024CAutoDeleteArray\u0040E\u0040RAII\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6GXXZ \u003F\u003F_7\u003F\u0024CAutoRelease\u0040PAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6GXXZ \u003F\u003F_7\u003F\u0024CAutoDelete\u0040PAVCGenericProgressShim\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6GXXZ \u003F\u003F_7CGenericProgressShim\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6GXXZ \u003F\u003F_7CDeviceNotificationCallbackShim\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CI\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1FA\u0040DFPBFODB\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAf\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAs\u003F\u0024AAh\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F5\u003F\u0024AAp\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAf\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAm\u003F\u0024AA\u003F5\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0FC\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1KE\u0040NICNNOJH\u0040\u003F\u0024AAM\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAm\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAc\u003F\u0024AAh\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAv\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAs\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AA\u003F5\u003F\u0024AAo\u003F\u0024AAf\u003F\u0024AA\u003F5\u003F\u0024AAn\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAv\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAf\u003F\u0024AAl\u003F\u0024AAa\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CD\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1EG\u0040HDIJANGN\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAc\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAf\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAs\u003F\u0024AAh\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F5\u003F\u0024AAp\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAf\u003F\u0024AAo\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CC\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1EE\u0040GEIPDOOK\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAc\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CK\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1FE\u0040BCHEDBFP\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAc\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DA\u0040\u0024\u0024CBG \u003F\u003F_C\u0040_1GA\u0040LFCCFCBB\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F5\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AAv\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAn\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAf\u003F\u0024AAi\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024CAutoDelete\u0040PAVCDeviceNotificationCallbackShim\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024CAutoCleanupBase\u0040PAVCDeviceNotificationCallbackShim\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024CAutoRelease\u0040PAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024CAutoCleanupBase\u0040PAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024CAutoRelease\u0040PAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024CAutoCleanupBase\u0040PAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoDelete\u0040PAVCDeviceNotificationCallbackShim\u0040\u0040\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoCleanupBase\u0040PAVCDeviceNotificationCallbackShim\u0040\u0040\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoRelease\u0040PAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoCleanupBase\u0040PAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoRelease\u0040PAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024CAutoCleanupBase\u0040PAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoCleanupBase\u0040PAVCDeviceNotificationCallbackShim\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_67 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoCleanupBase\u0040PAVCDeviceNotificationCallbackShim\u0040\u0040\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoDelete\u0040PAVCDeviceNotificationCallbackShim\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_62 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoDelete\u0040PAVCDeviceNotificationCallbackShim\u0040\u0040\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoCleanupBase\u0040PAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_79 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoCleanupBase\u0040PAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoRelease\u0040PAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_75 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoRelease\u0040PAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoCleanupBase\u0040PAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_70 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoCleanupBase\u0040PAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024CAutoRelease\u0040PAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_66 \u003F\u003F_R0\u003FAV\u003F\u0024CAutoRelease\u0040PAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024CAutoDelete\u0040PAVCDeviceNotificationCallbackShim\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024CAutoRelease\u0040PAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024CAutoRelease\u0040PAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6GXXZ \u003F\u003F_7\u003F\u0024CAutoRelease\u0040PAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6GXXZ \u003F\u003F_7\u003F\u0024CAutoRelease\u0040PAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6GXXZ \u003F\u003F_7\u003F\u0024CAutoDelete\u0040PAVCDeviceNotificationCallbackShim\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x2442659e\u002E\u003FInitializedPerProcess\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static int \u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static bool \u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static int \u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA;
  internal static TriBool.State \u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  [FixedAddressValueType]
  internal static int \u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static TriBool.State \u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static bool \u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  [FixedAddressValueType]
  internal static bool \u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static bool \u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x2442659e\u002E__xc_mp_z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x2442659e\u002E__xi_vt_z;
  internal static __FnPtr<void ()> \u003FA0x2442659e\u002E\u003FIsDefaultDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x2442659e\u002E__xc_ma_a;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x2442659e\u002E__xc_ma_z;
  internal static __FnPtr<void ()> \u003FA0x2442659e\u002E\u003FInitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0x2442659e\u002E\u003FInitializedPerAppDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x2442659e\u002E__xi_vt_a;
  internal static __FnPtr<void ()> \u003FA0x2442659e\u002E\u003FInitializedNative\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x2442659e\u002E__xc_mp_a;
  internal static __FnPtr<void ()> \u003FA0x2442659e\u002E\u003FInitializedVtables\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0x2442659e\u002E\u003FUninitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  public static unsafe int** __unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  public static unsafe int** __unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  internal static unsafe __FnPtr<void ()>* \u003FA0x103fe9b9\u002E__onexitbegin_m;
  internal static uint \u003FA0x103fe9b9\u002E__exit_list_size;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitend_app_domain;
  [FixedAddressValueType]
  internal static unsafe void* \u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA;
  [FixedAddressValueType]
  internal static int \u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  internal static unsafe __FnPtr<void ()>* \u003FA0x103fe9b9\u002E__onexitend_m;
  [FixedAddressValueType]
  internal static uint __exit_list_size_app_domain;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitbegin_app_domain;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040GHFPNOJB\u0040bad\u003F5allocation\u003F\u0024AA\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3exception\u0040\u00408;
  internal static bad_alloc \u003FA0xba0a35f5\u002E\u003Fnomem\u0040\u003F6\u003F\u003F\u003F_U\u0040YAPAXI\u0040Z\u00404Vbad_alloc\u0040std\u0040\u0040B;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2bad_alloc\u0040std\u0040\u00408;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_8 _CTA2\u003FAVbad_alloc\u0040std\u0040\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040bad_alloc\u0040std\u0040\u00408;
  internal static _s__ThrowInfo _TI2\u003FAVbad_alloc\u0040std\u0040\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVexception\u0040\u0040\u00408\u003F\u003F0exception\u0040\u0040\u0024\u0024FQAE\u0040ABV0\u0040\u0040Z12;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_16 \u003F\u003F_R0\u003FAVexception\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2exception\u0040\u00408;
  internal static unsafe sbyte* std\u002E_bad_alloc_Message;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3bad_alloc\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040exception\u0040\u00408;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408\u003F\u003F0bad_alloc\u0040std\u0040\u0040\u0024\u0024FQAE\u0040ABV01\u0040\u0040Z12;
  internal static uint \u003FA0xba0a35f5\u002E\u003F\u0024S1\u0040\u003F6\u003F\u003F\u003F_U\u0040YAPAXI\u0040Z\u00404IA;
  internal static __s_GUID _GUID_cb2f6723_ab3a_11d2_9c40_00c04fa30a3e;
  internal static __s_GUID _GUID_cb2f6722_ab3a_11d2_9c40_00c04fa30a3e;
  internal static __s_GUID _GUID_90f1a06c_7712_4762_86b5_7a5eba6bdb02;
  internal static __s_GUID _GUID_90f1a06e_7712_4762_86b5_7a5eba6bdb02;
  internal static __s_GUID _GUID_00000000_0000_0000_c000_000000000046;
  internal static unsafe void* \u003FA0x47ab7201\u002E\u003FBegin\u0040\u003F1\u003F\u003FIsPointerInMsvcrtDll\u0040\u003FA0x47ab7201\u0040\u0040YAHPAXPAH\u0040Z\u00404PAXA;
  internal static unsafe void* \u003FA0x47ab7201\u002E\u003FEnd\u0040\u003F1\u003F\u003FIsPointerInMsvcrtDll\u0040\u003FA0x47ab7201\u0040\u0040YAHPAXPAH\u0040Z\u00404PAXA;
  static unsafe int** __unep\u0040\u003F_errno\u0040\u0040\u0024\u0024J0YAPAHXZ;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040OEFGOMJK\u0040kernelbase\u003F4dll\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0N\u0040MDJJJHMB\u0040kernel32\u003F4dll\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0O\u0040NLDKAIKN\u0040EncodePointer\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0O\u0040KBPMFGHI\u0040DecodePointer\u003F\u0024AA\u0040;
  internal static bool \u003FA0x00a411d4\u002E\u003FfInitialized\u0040\u003F1\u003F\u003F_decode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404_NA;
  internal static bool \u003FA0x00a411d4\u002E\u003FfInitialized\u0040\u003F1\u003F\u003F_encode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404_NA;
  internal static __FnPtr<void* (void*)> \u003FA0x00a411d4\u002E\u003FpfnDecodePointer\u0040\u003F1\u003F\u003F_decode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404P6GPAX0\u0040ZA;
  internal static __FnPtr<void* (void*)> \u003FA0x00a411d4\u002E\u003FpfnEncodePointer\u0040\u003F1\u003F\u003F_encode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404P6GPAX0\u0040ZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003F\u003F_C\u0040_06OJHGLDPL\u0040\u003F\u0024CInull\u003F\u0024CJ\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003F\u003F_C\u0040_1O\u0040CEDCILHN\u0040\u003F\u0024AA\u003F\u0024CI\u003F\u0024AAn\u003F\u0024AAu\u003F\u0024AAl\u003F\u0024AAl\u003F\u0024AA\u003F\u0024CJ\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0FJ\u0040\u0024\u0024CBE __lookuptable_s;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6GXXZ \u003F\u003F_7type_info\u0040\u00406B\u0040;
  internal static CAtlComModule ATL\u002E_AtlComModule;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_z;
  internal static volatile __enative_startup_state __native_startup_state;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_a;
  internal static volatile unsafe void* __native_startup_lock;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_a;
  internal static volatile uint __native_dllmain_reason;
  internal static volatile uint __native_vcclrit_reason;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7type_info\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040\u0024\u0024CBE __lookuptable_s;
  internal static unsafe int* __imp___mb_cur_max;
  internal static unsafe ioinfo* __imp___badioinfo;
  internal static unsafe \u0024ArrayType\u0024\u0024\u0024BY0A\u0040PAUioinfo\u0040\u0040* __imp___pioinfo;
  internal static unsafe \u0024ArrayType\u0024\u0024\u0024BY0A\u0040U_iobuf\u0040\u0040* __imp__iob;

  internal static unsafe void ATL\u002ECAtlComModule\u002ETerm([In] CAtlComModule* obj0)
  {
    if (*(int*) obj0 == 0)
      return;
    _ATL_OBJMAP_ENTRY30** atlObjmapEntrY30Ptr1 = (_ATL_OBJMAP_ENTRY30**) *(int*) ((IntPtr) obj0 + 8);
    if ((UIntPtr) atlObjmapEntrY30Ptr1 < (UIntPtr) *(int*) ((IntPtr) obj0 + 12))
    {
      do
      {
        uint num1 = (uint) *(int*) atlObjmapEntrY30Ptr1;
        if (num1 != 0U)
        {
          _ATL_OBJMAP_ENTRY30* atlObjmapEntrY30Ptr2 = (_ATL_OBJMAP_ENTRY30*) num1;
          uint num2 = (uint) *(int*) ((IntPtr) atlObjmapEntrY30Ptr2 + 16);
          if (num2 != 0U)
          {
            int num3 = (int) num2;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            int num4 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) num3 + 8))((IntPtr) num3);
          }
          *(int*) ((IntPtr) atlObjmapEntrY30Ptr2 + 16) = 0;
        }
        atlObjmapEntrY30Ptr1 += 4;
      }
      while ((UIntPtr) atlObjmapEntrY30Ptr1 < (UIntPtr) *(int*) ((IntPtr) obj0 + 12));
    }
    \u003CModule\u003E.DeleteCriticalSection((_RTL_CRITICAL_SECTION*) ((IntPtr) obj0 + 16));
    *(int*) obj0 = 0;
  }

  internal static void \u003FA0xea60aed3\u002E\u003F\u003F__E_AtlReleaseManagedClassFactories\u0040ATL\u0040\u0040YMXXZ() => \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0xea60aed3\u002E\u003F\u003F__F_AtlReleaseManagedClassFactories\u0040ATL\u0040\u0040YMXXZ));

  internal static unsafe void \u003FA0xea60aed3\u002E\u003F\u003F__F_AtlReleaseManagedClassFactories\u0040ATL\u0040\u0040YMXXZ() => \u003CModule\u003E.ATL\u002ECAtlComModule\u002ETerm(&\u003CModule\u003E.ATL\u002E_AtlComModule);

  internal static unsafe void RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002EForget(
    [In] CAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe ushort* RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002ESteal(
    [In] CAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0)
  {
    int num = *(int*) ((IntPtr) obj0 + 4);
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return (ushort*) num;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002E\u0021(
    [In] CAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0)
  {
    ushort* numPtr = (ushort*) 0;
    CAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* unsignedShortConstPtr = obj0;
    ref ushort* local = ref numPtr;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (bool) __calli((__FnPtr<byte (IntPtr, ushort**)>) *(int*) (*(int*) obj0 + 28))((ushort**) unsignedShortConstPtr, (IntPtr) ref local);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002E\u0021\u003D(
    [In] CAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0,
    ushort** p)
  {
    CAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* unsignedShortConstPtr = obj0;
    ushort** numPtr = p;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<byte (IntPtr, ushort**)>) *(int*) (*(int*) obj0 + 28))((ushort**) unsignedShortConstPtr, (IntPtr) numPtr) == (byte) 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002E\u003D\u003D(
    [In] CAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0,
    ushort** p)
  {
    return *(int*) ((IntPtr) obj0 + 4) == *(int*) p;
  }

  internal static unsafe ushort* RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002E\u002EQBG(
    [In] CAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0)
  {
    return (ushort*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe ushort* RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002E\u002EPBG(
    [In] CAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0)
  {
    return (ushort*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe ushort* RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0)
  {
    return (ushort*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe ushort* RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0)
  {
    return (ushort*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe ushort** RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0)
  {
    return (ushort**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe ushort** RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0)
  {
    return (ushort**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe void RAII\u002ECAutoComFree\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002E\u003D(
    [In] CAutoComFree\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0,
    ushort* p)
  {
    CAutoComFree\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* unsignedShortConstPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    __calli((__FnPtr<void (IntPtr)>) *(int*) (*(int*) unsignedShortConstPtr + 48))((IntPtr) unsignedShortConstPtr);
    *(int*) ((IntPtr) obj0 + 4) = (int) p;
  }

  internal static unsafe void RAII\u002ECAutoComFree\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002ERelease(
    [In] CAutoComFree\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num == 0U)
      return;
    \u003CModule\u003E.CoTaskMemFree((void*) num);
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe void RAII\u002ECAutoComFree\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002E\u007Bdtor\u007D(
    [In] CAutoComFree\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoComFree\u0040PBG\u0040RAII\u0040\u00406B\u0040;
    uint num = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num == 0U)
      return;
    \u003CModule\u003E.CoTaskMemFree((void*) num);
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe void* RAII\u002ECAutoComFree\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002E__vecDelDtor(
    [In] CAutoComFree\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* obj0,
    uint A_0)
  {
    if (((int) A_0 & 2) != 0)
    {
      CAutoComFree\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E* p = (CAutoComFree\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, (uint) *(int*) p, (__FnPtr<void (void*)>) __methodptr(RAII\u002ECAutoComFree\u003Cunsigned\u0020short\u0020const\u0020\u002A\u003E\u002E\u007Bdtor\u007D));
      if (((int) A_0 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) p);
      return (void*) p;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoComFree\u0040PBG\u0040RAII\u0040\u00406B\u0040;
    uint num = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num != 0U)
    {
      \u003CModule\u003E.CoTaskMemFree((void*) num);
      *(int*) ((IntPtr) obj0 + 4) = 0;
    }
    if (((int) A_0 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe CDeviceNotificationCallbackShim* CDeviceNotificationCallbackShim\u002E\u007Bctor\u007D(
    [In] CDeviceNotificationCallbackShim* obj0,
    DeviceNotificationCallback Callback)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7CDeviceNotificationCallbackShim\u0040\u00406B\u0040;
    *(int*) ((IntPtr) obj0 + 4) = (int) ((IntPtr) GCHandle.Alloc((object) Callback)).ToPointer();
    return obj0;
  }

  internal static unsafe void CDeviceNotificationCallbackShim\u002EConnected(
    [In] CDeviceNotificationCallbackShim* obj0,
    ushort* DevicePath)
  {
    IntPtr ptr = (IntPtr) (void*) DevicePath;
    ((DeviceNotificationCallback) ((GCHandle) new IntPtr((void*) *(int*) ((IntPtr) obj0 + 4))).Target).Connected(Marshal.PtrToStringUni(ptr));
  }

  internal static unsafe void CDeviceNotificationCallbackShim\u002EDisconnected(
    [In] CDeviceNotificationCallbackShim* obj0,
    ushort* DevicePath)
  {
    IntPtr ptr = (IntPtr) (void*) DevicePath;
    ((DeviceNotificationCallback) ((GCHandle) new IntPtr((void*) *(int*) ((IntPtr) obj0 + 4))).Target).Disconnected(Marshal.PtrToStringUni(ptr));
  }

  internal static unsafe void CGenericProgressShim\u002ERegisterProgress(
    [In] CGenericProgressShim* obj0,
    uint Progress)
  {
    ((GenericProgress) ((GCHandle) new IntPtr((void*) *(int*) ((IntPtr) obj0 + 4))).Target).RegisterProgress(Progress);
  }

  internal static unsafe void RAII\u002ECAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E\u002EForget(
    [In] CAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe CGenericProgressShim* RAII\u002ECAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E\u002ESteal(
    [In] CAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E* obj0)
  {
    int num = *(int*) ((IntPtr) obj0 + 4);
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return (CGenericProgressShim*) num;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E\u002E\u0021(
    [In] CAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E* obj0)
  {
    CGenericProgressShim* cgenericProgressShimPtr1 = (CGenericProgressShim*) 0;
    CAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E* cgenericProgressShimPtr2 = obj0;
    ref CGenericProgressShim* local = ref cgenericProgressShimPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (bool) __calli((__FnPtr<byte (IntPtr, CGenericProgressShim**)>) *(int*) (*(int*) obj0 + 28))((CGenericProgressShim**) cgenericProgressShimPtr2, (IntPtr) ref local);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E\u002E\u0021\u003D(
    [In] CAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E* obj0,
    CGenericProgressShim** p)
  {
    CAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E* cgenericProgressShimPtr1 = obj0;
    CGenericProgressShim** cgenericProgressShimPtr2 = p;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<byte (IntPtr, CGenericProgressShim**)>) *(int*) (*(int*) obj0 + 28))((CGenericProgressShim**) cgenericProgressShimPtr1, (IntPtr) cgenericProgressShimPtr2) == (byte) 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E\u002E\u003D\u003D(
    [In] CAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E* obj0,
    CGenericProgressShim** p)
  {
    return *(int*) ((IntPtr) obj0 + 4) == *(int*) p;
  }

  internal static unsafe CGenericProgressShim* RAII\u002ECAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E\u002E\u002EQAVCGenericProgressShim\u0040\u0040(
    [In] CAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E* obj0)
  {
    return (CGenericProgressShim*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe CGenericProgressShim* RAII\u002ECAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E\u002E\u002EPAVCGenericProgressShim\u0040\u0040(
    [In] CAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E* obj0)
  {
    return (CGenericProgressShim*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe CGenericProgressShim* RAII\u002ECAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E* obj0)
  {
    return (CGenericProgressShim*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe CGenericProgressShim* RAII\u002ECAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E* obj0)
  {
    return (CGenericProgressShim*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe CGenericProgressShim** RAII\u002ECAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E* obj0)
  {
    return (CGenericProgressShim**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe CGenericProgressShim** RAII\u002ECAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003CCGenericProgressShim\u0020\u002A\u003E* obj0)
  {
    return (CGenericProgressShim**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe void RAII\u002ECAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E\u002E\u003D(
    [In] CAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E* obj0,
    CGenericProgressShim* p)
  {
    CAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E* cgenericProgressShimPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    __calli((__FnPtr<void (IntPtr)>) *(int*) (*(int*) cgenericProgressShimPtr + 48))((IntPtr) cgenericProgressShimPtr);
    *(int*) ((IntPtr) obj0 + 4) = (int) p;
  }

  internal static unsafe void RAII\u002ECAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E\u002ERelease(
    [In] CAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E* obj0)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num == 0U)
      return;
    CGenericProgressShim* cgenericProgressShimPtr = (CGenericProgressShim*) num;
    \u003CModule\u003E.gcroot\u003CMicrosoft\u003A\u003AWindows\u003A\u003AFlashing\u003A\u003APlatform\u003A\u003AGenericProgress\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMicrosoft\u003A\u003AWindows\u003A\u003AFlashing\u003A\u003APlatform\u003A\u003AGenericProgress\u0020\u005E\u003E*) ((IntPtr) cgenericProgressShimPtr + 4));
    \u003CModule\u003E.delete((void*) cgenericProgressShimPtr);
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe void RAII\u002ECAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E\u002E\u007Bdtor\u007D(
    [In] CAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoDelete\u0040PAVCGenericProgressShim\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
    \u003CModule\u003E.RAII\u002ECAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E\u002ERelease(obj0);
  }

  internal static unsafe void RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002EForget(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe IFlashingDevice* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002ESteal(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0)
  {
    int num = *(int*) ((IntPtr) obj0 + 4);
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return (IFlashingDevice*) num;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002E\u0021(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0)
  {
    IFlashingDevice* iflashingDevicePtr = (IFlashingDevice*) 0;
    CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* platformIflashingDevicePtr = obj0;
    ref IFlashingDevice* local = ref iflashingDevicePtr;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (bool) __calli((__FnPtr<byte (IntPtr, IFlashingDevice**)>) *(int*) (*(int*) obj0 + 28))((IFlashingDevice**) platformIflashingDevicePtr, (IntPtr) ref local);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002E\u0021\u003D(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0,
    IFlashingDevice** p)
  {
    CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* platformIflashingDevicePtr = obj0;
    IFlashingDevice** iflashingDevicePtr = p;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<byte (IntPtr, IFlashingDevice**)>) *(int*) (*(int*) obj0 + 28))((IFlashingDevice**) platformIflashingDevicePtr, (IntPtr) iflashingDevicePtr) == (byte) 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002E\u003D\u003D(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0,
    IFlashingDevice** p)
  {
    return *(int*) ((IntPtr) obj0 + 4) == *(int*) p;
  }

  internal static unsafe IFlashingDevice* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002E\u002EQAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0)
  {
    return (IFlashingDevice*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IFlashingDevice* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002E\u002EPAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0)
  {
    return (IFlashingDevice*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IFlashingDevice* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0)
  {
    return (IFlashingDevice*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IFlashingDevice* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0)
  {
    return (IFlashingDevice*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IFlashingDevice** RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0)
  {
    return (IFlashingDevice**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IFlashingDevice** RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0)
  {
    return (IFlashingDevice**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe void RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002E\u003D(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0,
    IFlashingDevice* p)
  {
    CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* platformIflashingDevicePtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    __calli((__FnPtr<void (IntPtr)>) *(int*) (*(int*) platformIflashingDevicePtr + 48))((IntPtr) platformIflashingDevicePtr);
    *(int*) ((IntPtr) obj0 + 4) = (int) p;
  }

  internal static unsafe void RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002ERelease(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num1 == 0U)
      return;
    int num2 = (int) num1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) num2 + 20))((IntPtr) num2);
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe void RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002E\u007Bdtor\u007D(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoRelease\u0040PAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
    \u003CModule\u003E.RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002ERelease(obj0);
  }

  internal static unsafe void RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E\u002EForget(
    [In] CAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe byte* RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E\u002ESteal(
    [In] CAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E* obj0)
  {
    int num = *(int*) ((IntPtr) obj0 + 4);
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return (byte*) num;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E\u002E\u0021(
    [In] CAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E* obj0)
  {
    byte* numPtr = (byte*) 0;
    CAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E* baseUnsignedCharPtr = obj0;
    ref byte* local = ref numPtr;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (bool) __calli((__FnPtr<byte (IntPtr, byte**)>) *(int*) (*(int*) obj0 + 28))((byte**) baseUnsignedCharPtr, (IntPtr) ref local);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E\u002E\u0021\u003D(
    [In] CAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E* obj0,
    byte** p)
  {
    CAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E* baseUnsignedCharPtr = obj0;
    byte** numPtr = p;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<byte (IntPtr, byte**)>) *(int*) (*(int*) obj0 + 28))((byte**) baseUnsignedCharPtr, (IntPtr) numPtr) == (byte) 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E\u002E\u003D\u003D(
    [In] CAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E* obj0,
    byte** p)
  {
    return *(int*) ((IntPtr) obj0 + 4) == *(int*) p;
  }

  internal static unsafe byte* RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E\u002E\u002EQAE(
    [In] CAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E* obj0)
  {
    return (byte*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe byte* RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E\u002E\u002EPAE(
    [In] CAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E* obj0)
  {
    return (byte*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe byte* RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E* obj0)
  {
    return (byte*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe byte* RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E* obj0)
  {
    return (byte*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe byte** RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E* obj0)
  {
    return (byte**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe byte** RAII\u002ECAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003Cunsigned\u0020char\u0020\u002A\u003E* obj0)
  {
    return (byte**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe void RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020char\u003E\u002E\u003D(
    [In] CAutoDeleteArray\u003Cunsigned\u0020char\u003E* obj0,
    byte* p)
  {
    CAutoDeleteArray\u003Cunsigned\u0020char\u003E* arrayUnsignedCharPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    __calli((__FnPtr<void (IntPtr)>) *(int*) (*(int*) arrayUnsignedCharPtr + 48))((IntPtr) arrayUnsignedCharPtr);
    *(int*) ((IntPtr) obj0 + 4) = (int) p;
  }

  internal static unsafe void RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020char\u003E\u002ERelease(
    [In] CAutoDeleteArray\u003Cunsigned\u0020char\u003E* obj0)
  {
    uint p = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (p == 0U)
      return;
    \u003CModule\u003E.delete\u005B\u005D((void*) p);
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe byte* RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020char\u003E\u002EP(
    [In] CAutoDeleteArray\u003Cunsigned\u0020char\u003E* obj0)
  {
    return (byte*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe byte* RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020char\u003E\u002EP(
    [In] CAutoDeleteArray\u003Cunsigned\u0020char\u003E* obj0)
  {
    return (byte*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe byte* RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020char\u003E\u002E\u005B\u005D(
    [In] CAutoDeleteArray\u003Cunsigned\u0020char\u003E* obj0,
    uint i)
  {
    return (byte*) (*(int*) ((IntPtr) obj0 + 4) + (int) i);
  }

  internal static unsafe byte* RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020char\u003E\u002E\u005B\u005D(
    [In] CAutoDeleteArray\u003Cunsigned\u0020char\u003E* obj0,
    uint i)
  {
    return (byte*) (*(int*) ((IntPtr) obj0 + 4) + (int) i);
  }

  internal static unsafe void RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020char\u003E\u002E\u007Bdtor\u007D(
    [In] CAutoDeleteArray\u003Cunsigned\u0020char\u003E* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoDeleteArray\u0040E\u0040RAII\u0040\u00406B\u0040;
    uint p = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (p == 0U)
      return;
    \u003CModule\u003E.delete\u005B\u005D((void*) p);
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe void RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E\u002E\u003D(
    [In] CAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E* obj0,
    ushort* p)
  {
    CAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E* unsignedShortConstPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    __calli((__FnPtr<void (IntPtr)>) *(int*) (*(int*) unsignedShortConstPtr + 48))((IntPtr) unsignedShortConstPtr);
    *(int*) ((IntPtr) obj0 + 4) = (int) p;
  }

  internal static unsafe void RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E\u002ERelease(
    [In] CAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E* obj0)
  {
    uint p = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (p == 0U)
      return;
    \u003CModule\u003E.delete\u005B\u005D((void*) p);
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe ushort* RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E\u002EP(
    [In] CAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E* obj0)
  {
    return (ushort*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe ushort* RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E\u002EP(
    [In] CAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E* obj0)
  {
    return (ushort*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe ushort* RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E\u002E\u005B\u005D(
    [In] CAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E* obj0,
    uint i)
  {
    return (ushort*) ((int) i * 2 + *(int*) ((IntPtr) obj0 + 4));
  }

  internal static unsafe ushort* RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E\u002E\u005B\u005D(
    [In] CAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E* obj0,
    uint i)
  {
    return (ushort*) ((int) i * 2 + *(int*) ((IntPtr) obj0 + 4));
  }

  internal static unsafe void RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] CAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoDeleteArray\u0040\u0024\u0024CBG\u0040RAII\u0040\u00406B\u0040;
    uint p = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (p == 0U)
      return;
    \u003CModule\u003E.delete\u005B\u005D((void*) p);
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe void RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002EForget(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe IConnectedDevice* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002ESteal(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0)
  {
    int num = *(int*) ((IntPtr) obj0 + 4);
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return (IConnectedDevice*) num;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002E\u0021(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0)
  {
    IConnectedDevice* iconnectedDevicePtr1 = (IConnectedDevice*) 0;
    CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* iconnectedDevicePtr2 = obj0;
    ref IConnectedDevice* local = ref iconnectedDevicePtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (bool) __calli((__FnPtr<byte (IntPtr, IConnectedDevice**)>) *(int*) (*(int*) obj0 + 28))((IConnectedDevice**) iconnectedDevicePtr2, (IntPtr) ref local);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002E\u0021\u003D(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0,
    IConnectedDevice** p)
  {
    CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* iconnectedDevicePtr1 = obj0;
    IConnectedDevice** iconnectedDevicePtr2 = p;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<byte (IntPtr, IConnectedDevice**)>) *(int*) (*(int*) obj0 + 28))((IConnectedDevice**) iconnectedDevicePtr1, (IntPtr) iconnectedDevicePtr2) == (byte) 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002E\u003D\u003D(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0,
    IConnectedDevice** p)
  {
    return *(int*) ((IntPtr) obj0 + 4) == *(int*) p;
  }

  internal static unsafe IConnectedDevice* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002E\u002EQAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0)
  {
    return (IConnectedDevice*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IConnectedDevice* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002E\u002EPAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0)
  {
    return (IConnectedDevice*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IConnectedDevice* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0)
  {
    return (IConnectedDevice*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IConnectedDevice* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0)
  {
    return (IConnectedDevice*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IConnectedDevice** RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0)
  {
    return (IConnectedDevice**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IConnectedDevice** RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0)
  {
    return (IConnectedDevice**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe void RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002E\u003D(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0,
    IConnectedDevice* p)
  {
    CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* iconnectedDevicePtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    __calli((__FnPtr<void (IntPtr)>) *(int*) (*(int*) iconnectedDevicePtr + 48))((IntPtr) iconnectedDevicePtr);
    *(int*) ((IntPtr) obj0 + 4) = (int) p;
  }

  internal static unsafe void RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002ERelease(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num1 == 0U)
      return;
    int num2 = (int) num1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) num2 + 20))((IntPtr) num2);
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe void RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002E\u007Bdtor\u007D(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoRelease\u0040PAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
    \u003CModule\u003E.RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002ERelease(obj0);
  }

  internal static unsafe void gcroot\u003CMicrosoft\u003A\u003AWindows\u003A\u003AFlashing\u003A\u003APlatform\u003A\u003AGenericProgress\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMicrosoft\u003A\u003AWindows\u003A\u003AFlashing\u003A\u003APlatform\u003A\u003AGenericProgress\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
    *(int*) obj0 = 0;
  }

  internal static unsafe void gcroot\u003CMicrosoft\u003A\u003AWindows\u003A\u003AFlashing\u003A\u003APlatform\u003A\u003ADeviceNotificationCallback\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMicrosoft\u003A\u003AWindows\u003A\u003AFlashing\u003A\u003APlatform\u003A\u003ADeviceNotificationCallback\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
    *(int*) obj0 = 0;
  }

  internal static unsafe void* RAII\u002ECAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E\u002E__vecDelDtor(
    [In] CAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E* obj0,
    uint A_0)
  {
    if (((int) A_0 & 2) != 0)
    {
      CAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E* p = (CAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, (uint) *(int*) p, (__FnPtr<void (void*)>) __methodptr(RAII\u002ECAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E\u002E\u007Bdtor\u007D));
      if (((int) A_0 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) p);
      return (void*) p;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoDelete\u0040PAVCGenericProgressShim\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
    \u003CModule\u003E.RAII\u002ECAutoDelete\u003CCGenericProgressShim\u0020\u002A\u003E\u002ERelease(obj0);
    if (((int) A_0 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002E__vecDelDtor(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* obj0,
    uint A_0)
  {
    if (((int) A_0 & 2) != 0)
    {
      CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E* p = (CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, (uint) *(int*) p, (__FnPtr<void (void*)>) __methodptr(RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002E\u007Bdtor\u007D));
      if (((int) A_0 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) p);
      return (void*) p;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoRelease\u0040PAUIFlashingDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
    \u003CModule\u003E.RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingDevice\u0020\u002A\u003E\u002ERelease(obj0);
    if (((int) A_0 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020char\u003E\u002E__vecDelDtor(
    [In] CAutoDeleteArray\u003Cunsigned\u0020char\u003E* obj0,
    uint A_0)
  {
    if (((int) A_0 & 2) != 0)
    {
      CAutoDeleteArray\u003Cunsigned\u0020char\u003E* p = (CAutoDeleteArray\u003Cunsigned\u0020char\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, (uint) *(int*) p, (__FnPtr<void (void*)>) __methodptr(RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020char\u003E\u002E\u007Bdtor\u007D));
      if (((int) A_0 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) p);
      return (void*) p;
    }
    \u003CModule\u003E.RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020char\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) A_0 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E\u002E__vecDelDtor(
    [In] CAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E* obj0,
    uint A_0)
  {
    if (((int) A_0 & 2) != 0)
    {
      CAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E* p = (CAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, (uint) *(int*) p, (__FnPtr<void (void*)>) __methodptr(RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) A_0 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) p);
      return (void*) p;
    }
    \u003CModule\u003E.RAII\u002ECAutoDeleteArray\u003Cunsigned\u0020short\u0020const\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) A_0 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002E__vecDelDtor(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* obj0,
    uint A_0)
  {
    if (((int) A_0 & 2) != 0)
    {
      CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E* p = (CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, (uint) *(int*) p, (__FnPtr<void (void*)>) __methodptr(RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002E\u007Bdtor\u007D));
      if (((int) A_0 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) p);
      return (void*) p;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoRelease\u0040PAUIConnectedDevice\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
    \u003CModule\u003E.RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDevice\u0020\u002A\u003E\u002ERelease(obj0);
    if (((int) A_0 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void RAII\u002ECAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002EForget(
    [In] CAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe CDeviceNotificationCallbackShim* RAII\u002ECAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002ESteal(
    [In] CAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0)
  {
    int num = *(int*) ((IntPtr) obj0 + 4);
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return (CDeviceNotificationCallbackShim*) num;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002E\u0021(
    [In] CAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0)
  {
    CDeviceNotificationCallbackShim* notificationCallbackShimPtr1 = (CDeviceNotificationCallbackShim*) 0;
    CAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* notificationCallbackShimPtr2 = obj0;
    ref CDeviceNotificationCallbackShim* local = ref notificationCallbackShimPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (bool) __calli((__FnPtr<byte (IntPtr, CDeviceNotificationCallbackShim**)>) *(int*) (*(int*) obj0 + 28))((CDeviceNotificationCallbackShim**) notificationCallbackShimPtr2, (IntPtr) ref local);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002E\u0021\u003D(
    [In] CAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0,
    CDeviceNotificationCallbackShim** p)
  {
    CAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* notificationCallbackShimPtr1 = obj0;
    CDeviceNotificationCallbackShim** notificationCallbackShimPtr2 = p;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<byte (IntPtr, CDeviceNotificationCallbackShim**)>) *(int*) (*(int*) obj0 + 28))((CDeviceNotificationCallbackShim**) notificationCallbackShimPtr1, (IntPtr) notificationCallbackShimPtr2) == (byte) 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002E\u003D\u003D(
    [In] CAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0,
    CDeviceNotificationCallbackShim** p)
  {
    return *(int*) ((IntPtr) obj0 + 4) == *(int*) p;
  }

  internal static unsafe CDeviceNotificationCallbackShim* RAII\u002ECAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002E\u002EQAVCDeviceNotificationCallbackShim\u0040\u0040(
    [In] CAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0)
  {
    return (CDeviceNotificationCallbackShim*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe CDeviceNotificationCallbackShim* RAII\u002ECAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002E\u002EPAVCDeviceNotificationCallbackShim\u0040\u0040(
    [In] CAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0)
  {
    return (CDeviceNotificationCallbackShim*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe CDeviceNotificationCallbackShim* RAII\u002ECAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0)
  {
    return (CDeviceNotificationCallbackShim*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe CDeviceNotificationCallbackShim* RAII\u002ECAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0)
  {
    return (CDeviceNotificationCallbackShim*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe CDeviceNotificationCallbackShim** RAII\u002ECAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0)
  {
    return (CDeviceNotificationCallbackShim**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe CDeviceNotificationCallbackShim** RAII\u002ECAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0)
  {
    return (CDeviceNotificationCallbackShim**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe void RAII\u002ECAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002E\u003D(
    [In] CAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0,
    CDeviceNotificationCallbackShim* p)
  {
    CAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* notificationCallbackShimPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    __calli((__FnPtr<void (IntPtr)>) *(int*) (*(int*) notificationCallbackShimPtr + 48))((IntPtr) notificationCallbackShimPtr);
    *(int*) ((IntPtr) obj0 + 4) = (int) p;
  }

  internal static unsafe void RAII\u002ECAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002ERelease(
    [In] CAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num == 0U)
      return;
    CDeviceNotificationCallbackShim* notificationCallbackShimPtr = (CDeviceNotificationCallbackShim*) num;
    \u003CModule\u003E.gcroot\u003CMicrosoft\u003A\u003AWindows\u003A\u003AFlashing\u003A\u003APlatform\u003A\u003ADeviceNotificationCallback\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMicrosoft\u003A\u003AWindows\u003A\u003AFlashing\u003A\u003APlatform\u003A\u003ADeviceNotificationCallback\u0020\u005E\u003E*) ((IntPtr) notificationCallbackShimPtr + 4));
    \u003CModule\u003E.delete((void*) notificationCallbackShimPtr);
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe void RAII\u002ECAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002E\u007Bdtor\u007D(
    [In] CAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoDelete\u0040PAVCDeviceNotificationCallbackShim\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
    \u003CModule\u003E.RAII\u002ECAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002ERelease(obj0);
  }

  internal static unsafe void RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002EForget(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe IConnectedDeviceCollection* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002ESteal(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0)
  {
    int num = *(int*) ((IntPtr) obj0 + 4);
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return (IConnectedDeviceCollection*) num;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002E\u0021(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0)
  {
    IConnectedDeviceCollection* deviceCollectionPtr1 = (IConnectedDeviceCollection*) 0;
    CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* deviceCollectionPtr2 = obj0;
    ref IConnectedDeviceCollection* local = ref deviceCollectionPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (bool) __calli((__FnPtr<byte (IntPtr, IConnectedDeviceCollection**)>) *(int*) (*(int*) obj0 + 28))((IConnectedDeviceCollection**) deviceCollectionPtr2, (IntPtr) ref local);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002E\u0021\u003D(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0,
    IConnectedDeviceCollection** p)
  {
    CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* deviceCollectionPtr1 = obj0;
    IConnectedDeviceCollection** deviceCollectionPtr2 = p;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<byte (IntPtr, IConnectedDeviceCollection**)>) *(int*) (*(int*) obj0 + 28))((IConnectedDeviceCollection**) deviceCollectionPtr1, (IntPtr) deviceCollectionPtr2) == (byte) 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002E\u003D\u003D(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0,
    IConnectedDeviceCollection** p)
  {
    return *(int*) ((IntPtr) obj0 + 4) == *(int*) p;
  }

  internal static unsafe IConnectedDeviceCollection* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002E\u002EQAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0)
  {
    return (IConnectedDeviceCollection*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IConnectedDeviceCollection* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002E\u002EPAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0)
  {
    return (IConnectedDeviceCollection*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IConnectedDeviceCollection* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0)
  {
    return (IConnectedDeviceCollection*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IConnectedDeviceCollection* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0)
  {
    return (IConnectedDeviceCollection*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IConnectedDeviceCollection** RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0)
  {
    return (IConnectedDeviceCollection**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IConnectedDeviceCollection** RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0)
  {
    return (IConnectedDeviceCollection**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe void RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002E\u003D(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0,
    IConnectedDeviceCollection* p)
  {
    CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* deviceCollectionPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    __calli((__FnPtr<void (IntPtr)>) *(int*) (*(int*) deviceCollectionPtr + 48))((IntPtr) deviceCollectionPtr);
    *(int*) ((IntPtr) obj0 + 4) = (int) p;
  }

  internal static unsafe void RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002ERelease(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num1 == 0U)
      return;
    int num2 = (int) num1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) num2 + 8))((IntPtr) num2);
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe void RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002E\u007Bdtor\u007D(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoRelease\u0040PAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
    \u003CModule\u003E.RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002ERelease(obj0);
  }

  internal static unsafe void RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002EForget(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe IFlashingPlatform* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002ESteal(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0)
  {
    int num = *(int*) ((IntPtr) obj0 + 4);
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return (IFlashingPlatform*) num;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002E\u0021(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0)
  {
    IFlashingPlatform* iflashingPlatformPtr1 = (IFlashingPlatform*) 0;
    CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* iflashingPlatformPtr2 = obj0;
    ref IFlashingPlatform* local = ref iflashingPlatformPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (bool) __calli((__FnPtr<byte (IntPtr, IFlashingPlatform**)>) *(int*) (*(int*) obj0 + 28))((IFlashingPlatform**) iflashingPlatformPtr2, (IntPtr) ref local);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002E\u0021\u003D(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0,
    IFlashingPlatform** p)
  {
    CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* iflashingPlatformPtr1 = obj0;
    IFlashingPlatform** iflashingPlatformPtr2 = p;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<byte (IntPtr, IFlashingPlatform**)>) *(int*) (*(int*) obj0 + 28))((IFlashingPlatform**) iflashingPlatformPtr1, (IntPtr) iflashingPlatformPtr2) == (byte) 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002E\u003D\u003D(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0,
    IFlashingPlatform** p)
  {
    return *(int*) ((IntPtr) obj0 + 4) == *(int*) p;
  }

  internal static unsafe IFlashingPlatform* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002E\u002EQAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0)
  {
    return (IFlashingPlatform*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IFlashingPlatform* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002E\u002EPAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0)
  {
    return (IFlashingPlatform*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IFlashingPlatform* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0)
  {
    return (IFlashingPlatform*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IFlashingPlatform* RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002E\u002D\u003E(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0)
  {
    return (IFlashingPlatform*) *(int*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IFlashingPlatform** RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0)
  {
    return (IFlashingPlatform**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe IFlashingPlatform** RAII\u002ECAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002E\u0026(
    [In] CAutoCleanupBase\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0)
  {
    return (IFlashingPlatform**) ((IntPtr) obj0 + 4);
  }

  internal static unsafe void RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002E\u003D(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0,
    IFlashingPlatform* p)
  {
    CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* iflashingPlatformPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    __calli((__FnPtr<void (IntPtr)>) *(int*) (*(int*) iflashingPlatformPtr + 48))((IntPtr) iflashingPlatformPtr);
    *(int*) ((IntPtr) obj0 + 4) = (int) p;
  }

  internal static unsafe void RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002ERelease(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num1 == 0U)
      return;
    int num2 = (int) num1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) num2 + 28))((IntPtr) num2);
    *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe void RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002E\u007Bdtor\u007D(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoRelease\u0040PAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
    \u003CModule\u003E.RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002ERelease(obj0);
  }

  internal static unsafe void* RAII\u002ECAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002E__vecDelDtor(
    [In] CAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* obj0,
    uint A_0)
  {
    if (((int) A_0 & 2) != 0)
    {
      CAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E* p = (CAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, (uint) *(int*) p, (__FnPtr<void (void*)>) __methodptr(RAII\u002ECAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002E\u007Bdtor\u007D));
      if (((int) A_0 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) p);
      return (void*) p;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoDelete\u0040PAVCDeviceNotificationCallbackShim\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
    \u003CModule\u003E.RAII\u002ECAutoDelete\u003CCDeviceNotificationCallbackShim\u0020\u002A\u003E\u002ERelease(obj0);
    if (((int) A_0 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002E__vecDelDtor(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* obj0,
    uint A_0)
  {
    if (((int) A_0 & 2) != 0)
    {
      CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E* p = (CAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, (uint) *(int*) p, (__FnPtr<void (void*)>) __methodptr(RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002E\u007Bdtor\u007D));
      if (((int) A_0 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) p);
      return (void*) p;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoRelease\u0040PAUIConnectedDeviceCollection\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
    \u003CModule\u003E.RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIConnectedDeviceCollection\u0020\u002A\u003E\u002ERelease(obj0);
    if (((int) A_0 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002E__vecDelDtor(
    [In] CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* obj0,
    uint A_0)
  {
    if (((int) A_0 & 2) != 0)
    {
      CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E* p = (CAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, (uint) *(int*) p, (__FnPtr<void (void*)>) __methodptr(RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002E\u007Bdtor\u007D));
      if (((int) A_0 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) p);
      return (void*) p;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024CAutoRelease\u0040PAUIFlashingPlatform\u0040FlashingPlatform\u0040\u0040\u0040RAII\u0040\u00406B\u0040;
    \u003CModule\u003E.RAII\u002ECAutoRelease\u003CFlashingPlatform\u003A\u003AIFlashingPlatform\u0020\u002A\u003E\u002ERelease(obj0);
    if (((int) A_0 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode() => (\u003CModule\u003E.__native_dllmain_reason != uint.MaxValue ? 1 : 0) == 0 || (\u003CModule\u003E.__native_vcclrit_reason != uint.MaxValue ? 1 : 0) != 0 || \u003CModule\u003E.__native_dllmain_reason != 1U && \u003CModule\u003E.__native_dllmain_reason != 0U;

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EDoNothing(
    void* cookie)
  {
    GC.KeepAlive((object) int.MaxValue);
    return 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess()
  {
    if (\u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr = (void**) &\u003CModule\u003E.\u003FA0x2442659e\u002E__xc_mp_a;
    if (ref \u003CModule\u003E.\u003FA0x2442659e\u002E__xc_mp_a < ref \u003CModule\u003E.\u003FA0x2442659e\u002E__xc_mp_z)
    {
      while (*(int*) voidPtr == 0)
      {
        voidPtr += 4;
        if ((IntPtr) voidPtr >= ref \u003CModule\u003E.\u003FA0x2442659e\u002E__xc_mp_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative()
  {
    if (\u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr1 = (void**) &\u003CModule\u003E.__xi_a;
    if (ref \u003CModule\u003E.__xi_a < ref \u003CModule\u003E.__xi_z)
    {
      while (*(int*) voidPtr1 == 0)
      {
        voidPtr1 += 4;
        if ((IntPtr) voidPtr1 >= ref \u003CModule\u003E.__xi_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    void** voidPtr2 = (void**) &\u003CModule\u003E.__xc_a;
    if (ref \u003CModule\u003E.__xc_a < ref \u003CModule\u003E.__xc_z)
    {
      while (*(int*) voidPtr2 == 0)
      {
        voidPtr2 += 4;
        if ((IntPtr) voidPtr2 >= ref \u003CModule\u003E.__xc_z)
          goto label_9;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_9:
    \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess() && !\u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA || \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative() && !\u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA && \u003CModule\u003E.__native_startup_state == (__enative_startup_state) 0;

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);

  internal static void \u003FA0x2442659e\u002E\u003F\u003F__E\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x2442659e\u002E\u003F\u003F__E\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x2442659e\u002E\u003F\u003F__E\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = false;

  internal static void \u003FA0x2442659e\u002E\u003F\u003F__E\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x2442659e\u002E\u003F\u003F__E\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x2442659e\u002E\u003F\u003F__E\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x2442659e\u002E\u003F\u003F__E\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(
    [In] LanguageSupport* obj0)
  {
    string str = "The C++ module failed to load during vtable initialization.\n";
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) str;
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x2442659e\u002E__xi_vt_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x2442659e\u002E__xi_vt_z);
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(
    [In] LanguageSupport* obj0)
  {
    string str = "The C++ module failed to load while attempting to initialize the default appdomain.\n";
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) str;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize();
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(
    [In] LanguageSupport* obj0)
  {
    string str = "The C++ module failed to load during native initialization.\n";
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) str;
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode())
      \u003CModule\u003E._amsg_exit(33);
    switch (\u003CModule\u003E.__native_startup_state)
    {
      case (__enative_startup_state) 0:
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 1;
        if (\u003CModule\u003E._initterm_e((__FnPtr<int ()>*) &\u003CModule\u003E.__xi_a, (__FnPtr<int ()>*) &\u003CModule\u003E.__xi_z) != 0)
          \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException((string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target);
        \u003CModule\u003E._initterm((__FnPtr<void ()>*) &\u003CModule\u003E.__xc_a, (__FnPtr<void ()>*) &\u003CModule\u003E.__xc_z);
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 2;
        \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
        break;
      case (__enative_startup_state) 1:
        \u003CModule\u003E._amsg_exit(33);
        break;
    }
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(
    [In] LanguageSupport* obj0)
  {
    string str = "The C++ module failed to load during process initialization.\n";
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) str;
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_m();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x2442659e\u002E__xc_mp_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x2442659e\u002E__xc_mp_z);
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(
    [In] LanguageSupport* obj0)
  {
    string str = "The C++ module failed to load during appdomain initialization.\n";
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) str;
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_app_domain();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x2442659e\u002E__xc_ma_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x2442659e\u002E__xc_ma_z);
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(
    [In] LanguageSupport* obj0)
  {
    string str = "The C++ module failed to load during registration for the unload events.\n";
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) str;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(new EventHandler(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload));
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(
    [In] LanguageSupport* obj0)
  {
    Interlocked.Increment(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA);
    \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = AppDomain.CurrentDomain.IsDefaultAppDomain();
    if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    void* fiberPtrId = \u003CModule\u003E._getFiberPtrId();
    int num1 = 0;
    int num2 = 0;
    int num3 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      while (num2 == 0)
      {
        try
        {
        }
        finally
        {
          IntPtr comparand = (IntPtr) 0;
          IntPtr num4 = (IntPtr) fiberPtrId;
          // ISSUE: cast to a reference type
          void* voidPtr = (void*) Interlocked.CompareExchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num4, comparand);
          if ((IntPtr) voidPtr == IntPtr.Zero)
            num2 = 1;
          else if (voidPtr == fiberPtrId)
          {
            num1 = 1;
            num2 = 1;
          }
        }
        if (num2 == 0)
          \u003CModule\u003E.Sleep(1000U);
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(obj0);
      if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      {
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(obj0);
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(obj0);
      }
      else if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization())
        num3 = 1;
    }
    finally
    {
      if (num1 == 0)
      {
        IntPtr num5 = (IntPtr) 0;
        // ISSUE: cast to a reference type
        Interlocked.Exchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num5);
      }
    }
    if (num3 != 0)
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(obj0);
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(obj0);
    \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 1;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(obj0);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain() => \u003CModule\u003E._app_exit_callback();

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain(
    void* cookie)
  {
    \u003CModule\u003E._exit_callback();
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    if (\u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
    {
      \u003CModule\u003E._cexit();
      \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 0;
      \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    }
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    return 0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain()
  {
    if (!\u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
      return;
    if (AppDomain.CurrentDomain.IsDefaultAppDomain())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain((void*) 0);
    }
    else
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);
    }
  }

  [PrePrepareMethod]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload(
    object source,
    EventArgs arguments)
  {
    if (\u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA == 0 || Interlocked.Exchange(ref \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA, 1) != 0)
      return;
    int num = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0 ? 1 : 0;
    \u003CModule\u003E._app_exit_callback();
    if ((byte) num == (byte) 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(
    [In] LanguageSupport* obj0,
    Exception innerException)
  {
    try
    {
      bool flag = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
      if (!flag)
        return;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, ex);
    }
    catch
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, (Exception) null);
    }
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(
    [In] LanguageSupport* obj0)
  {
    try
    {
      \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load.\n");
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(obj0);
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, ex);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException((string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target, ex);
    }
    catch
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, (Exception) null);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException((string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target, (Exception) null);
    }
  }

  [DebuggerStepThrough]
  static unsafe \u003CModule\u003E()
  {
    LanguageSupport languageSupport;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(&languageSupport);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(&languageSupport);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D), (void*) &languageSupport);
    }
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) &languageSupport);
  }

  internal static unsafe LanguageSupport* \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(
    [In] LanguageSupport* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(int*) obj0 = (int) num.ToPointer();
    return obj0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
  }

  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0,
    string t)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) t;
    return obj0;
  }

  internal static unsafe void gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
    *(int*) obj0 = 0;
  }

  [HandleProcessCorruptedStateExceptions]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [PrePrepareMethod]
  internal static unsafe _exception_handling_state_pointers_t* _get_exception_handling_state_uplevel(
    _exception_handling_state_pointers_t* p)
  {
    if (*(int*) p == 0)
    {
      _tiddata_managed* tiddataManagedPtr = \u003CModule\u003E._getptd();
      *(int*) p = (int) ((IntPtr) tiddataManagedPtr + 144);
      *(int*) ((IntPtr) p + 4) = (int) ((IntPtr) tiddataManagedPtr + 524);
      *(int*) ((IntPtr) p + 8) = (int) ((IntPtr) tiddataManagedPtr + 136);
      *(int*) ((IntPtr) p + 12) = (int) ((IntPtr) tiddataManagedPtr + 140);
      *(int*) ((IntPtr) p + 16) = (int) ((IntPtr) tiddataManagedPtr + 148);
      *(int*) ((IntPtr) p + 20) = (int) ((IntPtr) tiddataManagedPtr + 152);
    }
    return p;
  }

  [PrePrepareMethod]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe _tiddata_managed* _getptd()
  {
    _tiddata_managed* tiddataManagedPtr = \u003CModule\u003E._getptd_noexit();
    if ((IntPtr) tiddataManagedPtr == IntPtr.Zero)
      \u003CModule\u003E._amsg_exit(16);
    return tiddataManagedPtr;
  }

  [DebuggerStepThrough]
  internal static unsafe ValueType \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle() => (IntPtr) \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA != IntPtr.Zero ? (ValueType) GCHandle.FromIntPtr(new IntPtr(\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA)) : (ValueType) null;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(
    object value)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = GCHandle.ToIntPtr(GCHandle.Alloc(value)).ToPointer();
    else
      ((GCHandle) valueType).Target = value;
  }

  [DebuggerStepThrough]
  internal static object \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    return valueType != null ? ((GCHandle) valueType).Target : (object) null;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      return;
    ((GCHandle) valueType).Free();
    \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = (void*) 0;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef()
  {
    if ((\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get() != null ? 1 : 0) == 0)
    {
      \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = (void*) 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(new object());
      \u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA = 0;
    }
    ++\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x103fe9b9\u002E__global_lock()
  {
    bool flag = false;
    if ((\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get() != null ? 1 : 0) != 0)
    {
      Monitor.Enter(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x103fe9b9\u002E__global_unlock()
  {
    bool flag = false;
    if ((\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get() != null ? 1 : 0) != 0)
    {
      Monitor.Exit(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x103fe9b9\u002E__alloc_global_lock()
  {
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef();
    return \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get() != null;
  }

  internal static unsafe int _atexit_helper(
    __FnPtr<void ()> func,
    uint* __pexit_list_size,
    __FnPtr<void ()>** __ponexitend_e,
    __FnPtr<void ()>** __ponexitbegin_e)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0;
    if (func == null)
      return -1;
    int num1;
    if (\u003CModule\u003E.\u003FA0x103fe9b9\u002E__global_lock())
    {
      try
      {
        __FnPtr<void ()>* ptr1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) *(int*) __ponexitbegin_e);
        __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) *(int*) __ponexitend_e);
        int num2 = (int) ((IntPtr) local2 - (IntPtr) ptr1);
        if (*__pexit_list_size - 1U < (uint) num2 >> 2)
        {
          try
          {
            uint num3 = *__pexit_list_size * 4U;
            uint num4 = num3 >= 2048U ? 2048U : num3;
            IntPtr cb = new IntPtr((int) num3 + (int) num4);
            IntPtr num5 = Marshal.ReAllocHGlobal(new IntPtr((void*) ptr1), cb);
            local2 = (__FnPtr<void ()>*) ((IntPtr) num5.ToPointer() + num2);
            ptr1 = (__FnPtr<void ()>*) num5.ToPointer();
            uint num6 = *__pexit_list_size;
            uint num7 = 512U >= num6 ? num6 : 512U;
            *__pexit_list_size = num6 + num7;
          }
          catch (OutOfMemoryException ex)
          {
            IntPtr cb = new IntPtr((int) *__pexit_list_size * 4 + 8);
            IntPtr num8 = Marshal.ReAllocHGlobal(new IntPtr((void*) ptr1), cb);
            local2 = (__FnPtr<void ()>*) ((IntPtr) num8.ToPointer() - (IntPtr) ptr1 + (IntPtr) local2);
            ptr1 = (__FnPtr<void ()>*) num8.ToPointer();
            uint* numPtr = __pexit_list_size;
            int num9 = (int) *numPtr + 4;
            *numPtr = (uint) num9;
          }
        }
        *(int*) local2 = (int) func;
        __FnPtr<void ()>* ptr2 = (__FnPtr<void ()>*) ((IntPtr) local2 + 4);
        local1 = func;
        *(int*) __ponexitbegin_e = (int) \u003CModule\u003E._encode_pointer((void*) ptr1);
        *(int*) __ponexitend_e = (int) \u003CModule\u003E._encode_pointer((void*) ptr2);
      }
      catch (OutOfMemoryException ex)
      {
      }
      finally
      {
        \u003CModule\u003E.\u003FA0x103fe9b9\u002E__global_unlock();
      }
      if (local1 != null)
      {
        num1 = 0;
        goto label_12;
      }
    }
    num1 = -1;
label_12:
    return num1;
  }

  internal static unsafe void _exit_callback()
  {
    if (\u003CModule\u003E.\u003FA0x103fe9b9\u002E__exit_list_size == 0U)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x103fe9b9\u002E__onexitbegin_m);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x103fe9b9\u002E__onexitend_m);
    if ((IntPtr) local1 != new IntPtr(-1) && (IntPtr) local1 != IntPtr.Zero && (IntPtr) local2 != IntPtr.Zero)
    {
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 4;
            if (local2 < local1)
              goto label_7;
          }
          while ((IntPtr) *(int*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          void* voidPtr = \u003CModule\u003E._decode_pointer((void*) *(int*) local2);
          *(int*) local2 = (int) \u003CModule\u003E._encoded_null();
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) (IntPtr) voidPtr)();
          local5 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x103fe9b9\u002E__onexitbegin_m);
          local6 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x103fe9b9\u002E__onexitend_m);
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_7:
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
    }
    --\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
    if (\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA != 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct();
  }

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_m()
  {
    if (!\u003CModule\u003E.\u003FA0x103fe9b9\u002E__alloc_global_lock())
      return 0;
    \u003CModule\u003E.\u003FA0x103fe9b9\u002E__onexitbegin_m = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer(Marshal.AllocHGlobal(128).ToPointer());
    \u003CModule\u003E.\u003FA0x103fe9b9\u002E__onexitend_m = \u003CModule\u003E.\u003FA0x103fe9b9\u002E__onexitbegin_m;
    \u003CModule\u003E.\u003FA0x103fe9b9\u002E__exit_list_size = 32U;
    return 1;
  }

  internal static unsafe int _atexit_m(__FnPtr<void ()> func) => \u003CModule\u003E._atexit_helper((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) func), &\u003CModule\u003E.\u003FA0x103fe9b9\u002E__exit_list_size, &\u003CModule\u003E.\u003FA0x103fe9b9\u002E__onexitend_m, &\u003CModule\u003E.\u003FA0x103fe9b9\u002E__onexitbegin_m);

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_app_domain()
  {
    if (\u003CModule\u003E.\u003FA0x103fe9b9\u002E__alloc_global_lock())
    {
      \u003CModule\u003E.__onexitbegin_app_domain = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer(Marshal.AllocHGlobal(128).ToPointer());
      \u003CModule\u003E.__onexitend_app_domain = \u003CModule\u003E.__onexitbegin_app_domain;
      \u003CModule\u003E.__exit_list_size_app_domain = 32U;
    }
    return 1;
  }

  [HandleProcessCorruptedStateExceptions]
  internal static unsafe void _app_exit_callback()
  {
    if (\u003CModule\u003E.__exit_list_size_app_domain == 0U)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitend_app_domain);
    try
    {
      if ((IntPtr) local1 == new IntPtr(-1) || (IntPtr) local1 == IntPtr.Zero || (IntPtr) local2 == IntPtr.Zero)
        return;
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 4;
          }
          while (local2 >= local1 && (IntPtr) *(int*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          if (local2 >= local1)
          {
            // ISSUE: cast to a function pointer type
            __FnPtr<void ()> local7 = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) *(int*) local2);
            *(int*) local2 = (int) \u003CModule\u003E._encoded_null();
            // ISSUE: function pointer call
            __calli(local7)();
            local5 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
            local6 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitend_app_domain);
          }
          else
            goto label_14;
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_14:;
    }
    finally
    {
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
      --\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
      if (\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA == 0)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct();
    }
  }

  internal static unsafe bad_alloc* std\u002Ebad_alloc\u002E\u007Bctor\u007D(
    [In] bad_alloc* obj0)
  {
    \u003CModule\u003E.exception\u002E\u007Bctor\u007D((exception*) obj0);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
      bad_alloc* badAllocPtr = (bad_alloc*) ((IntPtr) obj0 + 4);
      if (*(int*) badAllocPtr == 0)
      {
        if (*(int*) ((IntPtr) obj0 + 8) == 0)
          *(int*) badAllocPtr = (int) \u003CModule\u003E.std\u002E_bad_alloc_Message;
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(exception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Ebad_alloc\u002E\u007Bdtor\u007D([In] bad_alloc* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.exception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe void* std\u002Ebad_alloc\u002E__vecDelDtor([In] bad_alloc* obj0, uint A_0)
  {
    if (((int) A_0 & 2) != 0)
    {
      bad_alloc* badAllocPtr = (bad_alloc*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 12U, (uint) *(int*) badAllocPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebad_alloc\u002E\u007Bdtor\u007D));
      if (((int) A_0 & 1) != 0)
        \u003CModule\u003E.delete((void*) badAllocPtr);
      return (void*) badAllocPtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.exception\u002E\u007Bdtor\u007D((exception*) obj0);
    if (((int) A_0 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* new\u005B\u005D(uint size)
  {
    void* voidPtr = \u003CModule\u003E.malloc(size);
    if ((IntPtr) voidPtr == IntPtr.Zero)
    {
      while (\u003CModule\u003E._callnewh(size) != 0)
      {
        voidPtr = \u003CModule\u003E.malloc(size);
        if ((IntPtr) voidPtr != IntPtr.Zero)
          goto label_11;
      }
      if (((int) \u003CModule\u003E.\u003FA0xba0a35f5\u002E\u003F\u0024S1\u0040\u003F6\u003F\u003F\u003F_U\u0040YAPAXI\u0040Z\u00404IA & 1) == 0)
      {
        \u003CModule\u003E.\u003FA0xba0a35f5\u002E\u003F\u0024S1\u0040\u003F6\u003F\u003F\u003F_U\u0040YAPAXI\u0040Z\u00404IA |= 1U;
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0xba0a35f5\u002E\u003Fnomem\u0040\u003F6\u003F\u003F\u003F_U\u0040YAPAXI\u0040Z\u00404Vbad_alloc\u0040std\u0040\u0040B);
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0xba0a35f5\u002E\u003F\u003F__Fnomem\u0040\u003F6\u003F\u003F\u003F_U\u0040YAPAXI\u0040Z\u0040YMXXZ));
        }
        __fault
        {
          \u003CModule\u003E.\u003FA0xba0a35f5\u002E\u003F\u0024S1\u0040\u003F6\u003F\u003F\u003F_U\u0040YAPAXI\u0040Z\u00404IA &= 4294967294U;
        }
      }
      bad_alloc badAlloc;
      \u003CModule\u003E.exception\u002E\u007Bctor\u007D((exception*) &badAlloc, (exception*) &\u003CModule\u003E.\u003FA0xba0a35f5\u002E\u003Fnomem\u0040\u003F6\u003F\u003F\u003F_U\u0040YAPAXI\u0040Z\u00404Vbad_alloc\u0040std\u0040\u0040B);
      // ISSUE: fault handler
      try
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref badAlloc = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(exception\u002E\u007Bdtor\u007D), (void*) &badAlloc);
      }
      \u003CModule\u003E._CxxThrowException((void*) &badAlloc, &\u003CModule\u003E._TI2\u003FAVbad_alloc\u0040std\u0040\u0040);
    }
label_11:
    return voidPtr;
  }

  internal static unsafe void \u003FA0xba0a35f5\u002E\u003F\u003F__Fnomem\u0040\u003F6\u003F\u003F\u003F_U\u0040YAPAXI\u0040Z\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0xba0a35f5\u002E\u003Fnomem\u0040\u003F6\u003F\u003F\u003F_U\u0040YAPAXI\u0040Z\u00404Vbad_alloc\u0040std\u0040\u0040B);

  [SpecialName]
  internal static unsafe bad_alloc* std\u002Ebad_alloc\u002E\u007Bctor\u007D(
    [In] bad_alloc* obj0,
    bad_alloc* A_0)
  {
    \u003CModule\u003E.exception\u002E\u007Bctor\u007D((exception*) obj0, (exception*) A_0);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(exception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void delete\u005B\u005D(void* p) => \u003CModule\u003E.free(p);

  internal static unsafe int _vsnwprintf_s(
    char* _Dst,
    uint _SizeInWords,
    uint _Count,
    char* _Format,
    sbyte* _ArgList)
  {
    if ((IntPtr) _Format == IntPtr.Zero)
    {
      *\u003CModule\u003E._errno() = 22;
      \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
      return -1;
    }
    if (_Count == 0U)
    {
      if ((IntPtr) _Dst == IntPtr.Zero)
      {
        if (_SizeInWords == 0U)
          return 0;
        goto label_8;
      }
    }
    else if ((IntPtr) _Dst == IntPtr.Zero)
      goto label_8;
    if (_SizeInWords > 0U)
    {
      int num;
      if (_SizeInWords > _Count)
      {
        num = \u003CModule\u003E._swoutput_s(_Dst, _Count + 1U, _Format, _ArgList);
        if (num == -2)
          return -1;
      }
      else
      {
        num = \u003CModule\u003E._swoutput_s(_Dst, _SizeInWords, _Format, _ArgList);
        if (num == -2)
        {
          if (_Count == uint.MaxValue)
            return -1;
          goto label_16;
        }
      }
      if (num >= 0)
        return num;
label_16:
      *_Dst = char.MinValue;
      if (num != -2)
        return -1;
      *\u003CModule\u003E._errno() = 34;
      \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
      return -1;
    }
label_8:
    *\u003CModule\u003E._errno() = 22;
    \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    return -1;
  }

  [HandleProcessCorruptedStateExceptions]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ehvec_dtor(
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    int num = 0;
    ptr = (void*) ((int) size * count + (IntPtr) ptr);
    try
    {
      while (true)
      {
        --count;
        if (count >= 0)
        {
          ptr -= (int) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
      num = 1;
    }
    finally
    {
      if (num == 0)
        \u003CModule\u003E.__ArrayUnwind(ptr, size, count, pDtor);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ehvec_dtor(
    void* ptr,
    uint size,
    uint count,
    __FnPtr<void (void*)> pDtor)
  {
    \u003CModule\u003E.__ehvec_dtor(ptr, size, (int) count, pDtor);
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [HandleProcessCorruptedStateExceptions]
  internal static void __ArrayUnwind(void* ptr, uint size, int count, __FnPtr<void (void*)> pDtor)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(
    Exception innerException,
    Exception nestedException)
  {
    throw new ModuleLoadExceptionHandlerException("A nested exception occurred after the primary exception that caused the C++ module to fail to load.\n", innerException, nestedException);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    string errorMessage)
  {
    throw new ModuleLoadException(errorMessage);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    string errorMessage,
    Exception innerException)
  {
    throw new ModuleLoadException(errorMessage, innerException);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(
    EventHandler handler)
  {
    ModuleUninitializer._ModuleUninitializer.AddHandler(handler);
  }

  [HandleProcessCorruptedStateExceptions]
  internal static unsafe int __get_default_appdomain(IUnknown** ppUnk)
  {
    int defaultAppdomain = 0;
    IUnknown* iunknownPtr1 = (IUnknown*) 0;
    ICorRuntimeHost* icorRuntimeHostPtr1 = (ICorRuntimeHost*) 0;
    try
    {
      defaultAppdomain = \u003CModule\u003E.CoCreateInstance((_GUID*) &\u003CModule\u003E._GUID_cb2f6723_ab3a_11d2_9c40_00c04fa30a3e, (IUnknown*) 0, 1U, (_GUID*) &\u003CModule\u003E._GUID_00000000_0000_0000_c000_000000000046, (void**) &iunknownPtr1);
      if (defaultAppdomain >= 0)
      {
        IUnknown* iunknownPtr2 = iunknownPtr1;
        ref __s_GUID local1 = ref \u003CModule\u003E._GUID_cb2f6722_ab3a_11d2_9c40_00c04fa30a3e;
        ref ICorRuntimeHost* local2 = ref icorRuntimeHostPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        defaultAppdomain = __calli((__FnPtr<int (IntPtr, _GUID*, void**)>) *(int*) *(int*) iunknownPtr1)((void**) iunknownPtr2, (_GUID*) ref local1, (IntPtr) ref local2);
        if (defaultAppdomain >= 0)
        {
          ICorRuntimeHost* icorRuntimeHostPtr2 = icorRuntimeHostPtr1;
          IUnknown** iunknownPtr3 = ppUnk;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          defaultAppdomain = __calli((__FnPtr<int (IntPtr, IUnknown**)>) *(int*) (*(int*) icorRuntimeHostPtr1 + 52))((IUnknown**) icorRuntimeHostPtr2, (IntPtr) iunknownPtr3);
        }
      }
    }
    finally
    {
      if ((IntPtr) iunknownPtr1 != IntPtr.Zero)
      {
        IUnknown* iunknownPtr4 = iunknownPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iunknownPtr4 + 8))((IntPtr) iunknownPtr4);
      }
      if ((IntPtr) icorRuntimeHostPtr1 != IntPtr.Zero)
      {
        ICorRuntimeHost* icorRuntimeHostPtr3 = icorRuntimeHostPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) icorRuntimeHostPtr3 + 8))((IntPtr) icorRuntimeHostPtr3);
      }
    }
    return defaultAppdomain;
  }

  internal static unsafe AppDomain \u003CCrtImplementationDetails\u003E\u002EGetDefaultDomain()
  {
    IUnknown* iunknownPtr1 = (IUnknown*) 0;
    int defaultAppdomain = \u003CModule\u003E.__get_default_appdomain(&iunknownPtr1);
    if (defaultAppdomain >= 0)
    {
      try
      {
        return (AppDomain) Marshal.GetObjectForIUnknown(new IntPtr((void*) iunknownPtr1));
      }
      finally
      {
        IUnknown* iunknownPtr2 = iunknownPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iunknownPtr2 + 8))((IntPtr) iunknownPtr2);
      }
    }
    else
    {
      Marshal.ThrowExceptionForHR(defaultAppdomain);
      return (AppDomain) null;
    }
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain(
    __FnPtr<int (void*)> function,
    void* cookie)
  {
    ICLRRuntimeHost* iclrRuntimeHostPtr1 = (ICLRRuntimeHost*) 0;
    try
    {
      int runtimeEx = \u003CModule\u003E.CorBindToRuntimeEx((char*) 0, (char*) 0, 0U, (_GUID*) &\u003CModule\u003E._GUID_90f1a06e_7712_4762_86b5_7a5eba6bdb02, (_GUID*) &\u003CModule\u003E._GUID_90f1a06c_7712_4762_86b5_7a5eba6bdb02, (void**) &iclrRuntimeHostPtr1);
      if (runtimeEx < 0)
        Marshal.ThrowExceptionForHR(runtimeEx);
      AppDomain defaultDomain = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EGetDefaultDomain();
      ICLRRuntimeHost* iclrRuntimeHostPtr2 = iclrRuntimeHostPtr1;
      int id = defaultDomain.Id;
      __FnPtr<int (void*)> local = function;
      void* voidPtr = cookie;
      // ISSUE: cast to a function pointer type
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int errorCode = __calli((__FnPtr<int (IntPtr, uint, __FnPtr<int (void*)>, void*)>) *(int*) (*(int*) iclrRuntimeHostPtr1 + 32))((void*) iclrRuntimeHostPtr2, (__FnPtr<int (void*)>) id, (uint) local, (IntPtr) voidPtr);
      if (errorCode >= 0)
        return;
      Marshal.ThrowExceptionForHR(errorCode);
    }
    finally
    {
      if ((IntPtr) iclrRuntimeHostPtr1 != IntPtr.Zero)
      {
        ICLRRuntimeHost* iclrRuntimeHostPtr3 = iclrRuntimeHostPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr3 + 8))((IntPtr) iclrRuntimeHostPtr3);
      }
    }
  }

  [DebuggerStepThrough]
  internal static unsafe int _initterm_e(__FnPtr<int ()>* pfbegin, __FnPtr<int ()>* pfend)
  {
    int num1 = 0;
    if (pfbegin < pfend)
    {
      while (num1 == 0)
      {
        uint num2 = (uint) *(int*) pfbegin;
        if (num2 != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          num1 = __calli((__FnPtr<int ()>) (int) num2)();
        }
        pfbegin += 4;
        if (pfbegin >= pfend)
          break;
      }
    }
    return num1;
  }

  [DebuggerStepThrough]
  internal static unsafe void _initterm(__FnPtr<void ()>* pfbegin, __FnPtr<void ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint num = (uint) *(int*) pfbegin;
      if (num != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) (int) num)();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static ModuleHandle \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle() => typeof (ThisModule).Module.ModuleHandle;

  [DebuggerStepThrough]
  internal static unsafe void _initterm_m(__FnPtr<void* ()>* pfbegin, __FnPtr<void* ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint methodToken = (uint) *(int*) pfbegin;
      if (methodToken != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        void* voidPtr = __calli(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E((__FnPtr<void* ()>) (int) methodToken))();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static unsafe __FnPtr<void* ()> \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E(
    __FnPtr<void* ()> methodToken)
  {
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void* ()>) (IntPtr) \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle().ResolveMethodHandle((int) methodToken).GetFunctionPointer().ToPointer();
  }

  internal static unsafe int __FrameUnwindFilter(_EXCEPTION_POINTERS* pExPtrs)
  {
    _exception_handling_state_pointers_t handlingStatePointersT;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref handlingStatePointersT = 0;
    // ISSUE: cast to a reference type
    // ISSUE: initblk instruction
    __memset((_exception_handling_state_pointers_t&) ((IntPtr) &handlingStatePointersT + 4), 0, 20);
    switch ((uint) *(int*) *(int*) pExPtrs)
    {
      case 3762504530:
      case 3762507597:
        if (*(int*) *(int*) \u003CModule\u003E._get_exception_handling_state(&handlingStatePointersT) > 0)
        {
          int num = *(int*) \u003CModule\u003E._get_exception_handling_state(&handlingStatePointersT);
          *(int*) num = *(int*) num - 1;
        }
        return 0;
      case 3765269347:
        *(int*) *(int*) \u003CModule\u003E._get_exception_handling_state(&handlingStatePointersT) = 0;
        \u003CModule\u003E.terminate();
        goto case 3762504530;
      default:
        return 0;
    }
  }

  [PrePrepareMethod]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe int \u003FA0x47ab7201\u002EGetDllBaseAndSizeFromAddress(
    void* Address,
    void** OutBase,
    uint* OutSize)
  {
    _MEMORY_BASIC_INFORMATION basicInformation;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref basicInformation = 0;
    // ISSUE: cast to a reference type
    // ISSUE: initblk instruction
    __memset((_MEMORY_BASIC_INFORMATION&) ((IntPtr) &basicInformation + 4), 0, 24);
    int andSizeFromAddress = 0;
    if ((IntPtr) OutBase != IntPtr.Zero)
      *(int*) OutBase = 0;
    if ((IntPtr) OutSize != IntPtr.Zero)
      *OutSize = 0U;
    if ((IntPtr) Address != IntPtr.Zero && (IntPtr) OutBase != IntPtr.Zero && (IntPtr) OutSize != IntPtr.Zero && \u003CModule\u003E.VirtualQuery(Address, &basicInformation, 28U) == 28U)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      void* voidPtr = (void*) ^(int&) ((IntPtr) &basicInformation + 4);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      do
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        Address = (void*) (^(int&) ((IntPtr) &basicInformation + 12) + ^(int&) ref basicInformation);
        if (\u003CModule\u003E.VirtualQuery(Address, &basicInformation, 28U) != 28U)
          goto label_9;
      }
      while ((IntPtr) voidPtr == (IntPtr) ^(int&) ((IntPtr) &basicInformation + 4));
      *(int*) OutBase = (int) voidPtr;
      *OutSize = (uint) (int) ((IntPtr) Address - (IntPtr) voidPtr);
      andSizeFromAddress = 1;
    }
label_9:
    return andSizeFromAddress;
  }

  [PrePrepareMethod]
  internal static unsafe int \u003FA0x47ab7201\u002EIsPointerInMsvcrtDll(void* p, int* Result)
  {
    int num1 = 0;
    if ((IntPtr) Result != IntPtr.Zero)
      *Result = 0;
    if ((IntPtr) p != IntPtr.Zero && (IntPtr) Result != IntPtr.Zero)
    {
      if ((IntPtr) \u003CModule\u003E.\u003FA0x47ab7201\u002E\u003FBegin\u0040\u003F1\u003F\u003FIsPointerInMsvcrtDll\u0040\u003FA0x47ab7201\u0040\u0040YAHPAXPAH\u0040Z\u00404PAXA == IntPtr.Zero || (IntPtr) \u003CModule\u003E.\u003FA0x47ab7201\u002E\u003FEnd\u0040\u003F1\u003F\u003FIsPointerInMsvcrtDll\u0040\u003FA0x47ab7201\u0040\u0040YAHPAXPAH\u0040Z\u00404PAXA == IntPtr.Zero)
      {
        uint num2;
        if (\u003CModule\u003E.\u003FA0x47ab7201\u002EGetDllBaseAndSizeFromAddress((void*) \u003CModule\u003E.__unep\u0040\u003F_errno\u0040\u0040\u0024\u0024J0YAPAHXZ, &\u003CModule\u003E.\u003FA0x47ab7201\u002E\u003FBegin\u0040\u003F1\u003F\u003FIsPointerInMsvcrtDll\u0040\u003FA0x47ab7201\u0040\u0040YAHPAXPAH\u0040Z\u00404PAXA, &num2) != 0)
          \u003CModule\u003E.\u003FA0x47ab7201\u002E\u003FEnd\u0040\u003F1\u003F\u003FIsPointerInMsvcrtDll\u0040\u003FA0x47ab7201\u0040\u0040YAHPAXPAH\u0040Z\u00404PAXA = (void*) ((IntPtr) \u003CModule\u003E.\u003FA0x47ab7201\u002E\u003FBegin\u0040\u003F1\u003F\u003FIsPointerInMsvcrtDll\u0040\u003FA0x47ab7201\u0040\u0040YAHPAXPAH\u0040Z\u00404PAXA + (int) num2);
        else
          goto label_7;
      }
      int num3 = p < \u003CModule\u003E.\u003FA0x47ab7201\u002E\u003FBegin\u0040\u003F1\u003F\u003FIsPointerInMsvcrtDll\u0040\u003FA0x47ab7201\u0040\u0040YAHPAXPAH\u0040Z\u00404PAXA || p >= \u003CModule\u003E.\u003FA0x47ab7201\u002E\u003FEnd\u0040\u003F1\u003F\u003FIsPointerInMsvcrtDll\u0040\u003FA0x47ab7201\u0040\u0040YAHPAXPAH\u0040Z\u00404PAXA ? 0 : 1;
      *Result = num3;
      num1 = 1;
    }
label_7:
    return num1;
  }

  [PrePrepareMethod]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe _tiddata_managed* _getptd_noexit()
  {
    int lastError = (int) \u003CModule\u003E.GetLastError();
    _tiddata_managed* tiddataManagedPtr = (_tiddata_managed*) 0;
    if ((\u003CModule\u003E.GetVersion() & (uint) byte.MaxValue) >= 6U)
    {
      int* p = \u003CModule\u003E._errno();
      int num = 0;
      if (\u003CModule\u003E.\u003FA0x47ab7201\u002EIsPointerInMsvcrtDll((void*) p, &num) != 0 && num == 0)
        tiddataManagedPtr = (_tiddata_managed*) (p - 2);
    }
    \u003CModule\u003E.SetLastError((uint) lastError);
    return tiddataManagedPtr;
  }

  internal static unsafe void* GetKernelProc(sbyte* pszFunction)
  {
    void* kernelProc = (void*) 0;
    HINSTANCE__* moduleHandleA = \u003CModule\u003E.GetModuleHandleA((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0P\u0040OEFGOMJK\u0040kernelbase\u003F4dll\u003F\u0024AA\u0040);
    if ((IntPtr) moduleHandleA == IntPtr.Zero)
    {
      moduleHandleA = \u003CModule\u003E.GetModuleHandleA((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0N\u0040MDJJJHMB\u0040kernel32\u003F4dll\u003F\u0024AA\u0040);
      if ((IntPtr) moduleHandleA == IntPtr.Zero)
        goto label_3;
    }
    kernelProc = (void*) \u003CModule\u003E.GetProcAddress(moduleHandleA, pszFunction);
label_3:
    return kernelProc;
  }

  internal static unsafe void* _encode_pointer(void* ptr)
  {
    if (!\u003CModule\u003E.\u003FA0x00a411d4\u002E\u003FfInitialized\u0040\u003F1\u003F\u003F_encode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404_NA)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.\u003FA0x00a411d4\u002E\u003FpfnEncodePointer\u0040\u003F1\u003F\u003F_encode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404P6GPAX0\u0040ZA = (__FnPtr<void* (void*)>) (IntPtr) \u003CModule\u003E.GetKernelProc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0O\u0040NLDKAIKN\u0040EncodePointer\u003F\u0024AA\u0040);
      \u003CModule\u003E.\u003FA0x00a411d4\u002E\u003FfInitialized\u0040\u003F1\u003F\u003F_encode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404_NA = true;
    }
    if (\u003CModule\u003E.\u003FA0x00a411d4\u002E\u003FpfnEncodePointer\u0040\u003F1\u003F\u003F_encode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404P6GPAX0\u0040ZA != null)
    {
      void* voidPtr = ptr;
      // ISSUE: function pointer call
      ptr = __calli(\u003CModule\u003E.\u003FA0x00a411d4\u002E\u003FpfnEncodePointer\u0040\u003F1\u003F\u003F_encode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404P6GPAX0\u0040ZA)(voidPtr);
    }
    return ptr;
  }

  internal static unsafe void* _encoded_null() => \u003CModule\u003E._encode_pointer((void*) 0);

  internal static unsafe void* _decode_pointer(void* codedptr)
  {
    if (!\u003CModule\u003E.\u003FA0x00a411d4\u002E\u003FfInitialized\u0040\u003F1\u003F\u003F_decode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404_NA)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.\u003FA0x00a411d4\u002E\u003FpfnDecodePointer\u0040\u003F1\u003F\u003F_decode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404P6GPAX0\u0040ZA = (__FnPtr<void* (void*)>) (IntPtr) \u003CModule\u003E.GetKernelProc((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0O\u0040KBPMFGHI\u0040DecodePointer\u003F\u0024AA\u0040);
      \u003CModule\u003E.\u003FA0x00a411d4\u002E\u003FfInitialized\u0040\u003F1\u003F\u003F_decode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404_NA = true;
    }
    if (\u003CModule\u003E.\u003FA0x00a411d4\u002E\u003FpfnDecodePointer\u0040\u003F1\u003F\u003F_decode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404P6GPAX0\u0040ZA != null)
    {
      void* voidPtr = codedptr;
      // ISSUE: function pointer call
      codedptr = __calli(\u003CModule\u003E.\u003FA0x00a411d4\u002E\u003FpfnDecodePointer\u0040\u003F1\u003F\u003F_decode_pointer\u0040\u0040YAPAXPAX\u0040Z\u00404P6GPAX0\u0040ZA)(voidPtr);
    }
    return codedptr;
  }

  internal static unsafe ushort \u003FA0xf690dbd3\u002E_putwc_nolock([MarshalAs(UnmanagedType.U2)] char _c, _iobuf* _stream)
  {
    *(int*) ((IntPtr) _stream + 4) = *(int*) ((IntPtr) _stream + 4) - 2;
    if (*(int*) ((IntPtr) _stream + 4) >= 0)
    {
      *(short*) *(int*) _stream = (short) _c;
      _iobuf* iobufPtr = _stream;
      int num = *(int*) iobufPtr + 2;
      *(int*) iobufPtr = num;
      return (ushort) _c;
    }
    *(int*) ((IntPtr) _stream + 12) = *(int*) ((IntPtr) _stream + 12) | 32;
    return ushort.MaxValue;
  }

  internal static unsafe int _swoutput_s(char* _Dst, uint _Size, char* _Format, sbyte* _ArgList)
  {
    _iobuf iobuf;
    switch (_Size)
    {
      case 0:
        *\u003CModule\u003E._errno() = 22;
        \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        return -1;
      case uint.MaxValue:
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &iobuf + 4) = int.MaxValue;
        break;
      default:
        if (_Size > 1073741823U)
        {
          *\u003CModule\u003E._errno() = 22;
          \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
          return -1;
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &iobuf + 4) = (int) _Size << 1;
        break;
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &iobuf + 8) = (int) _Dst;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref iobuf = (int) _Dst;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &iobuf + 12) = 66;
    int num = \u003CModule\u003E._woutput_s(&iobuf, _Format, _ArgList);
    *(short*) ((int) _Size * 2 + (IntPtr) _Dst - 2) = (short) 0;
    if (num < 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ((IntPtr) &iobuf + 4) < 0)
        return -2;
      if ((IntPtr) _Dst != IntPtr.Zero && _Size > 0U)
        *_Dst = char.MinValue;
      return num;
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &iobuf + 4) = ^(int&) ((IntPtr) &iobuf + 4) - 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ((IntPtr) &iobuf + 4) >= 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      *(sbyte*) ^(int&) ref iobuf = (sbyte) 0;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref iobuf = ^(int&) ref iobuf + 1;
    }
    else if (\u003CModule\u003E._flsbuf_s(0, &iobuf) == -1)
      goto label_19;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &iobuf + 4) = ^(int&) ((IntPtr) &iobuf + 4) - 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ((IntPtr) &iobuf + 4) >= 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      *(sbyte*) ^(int&) ref iobuf = (sbyte) 0;
    }
    else if (\u003CModule\u003E._flsbuf_s(0, &iobuf) == -1)
      goto label_19;
    return num;
label_19:
    return -2;
  }

  internal static unsafe void \u003FA0xf690dbd3\u002Ewrite_char(
    [MarshalAs(UnmanagedType.U2)] char ch,
    _iobuf* f,
    int* pnumwritten)
  {
    if ((*(int*) ((IntPtr) f + 12) & 64) != 0 && *(int*) ((IntPtr) f + 8) == 0)
    {
      int* numPtr = pnumwritten;
      int num = *numPtr + 1;
      *numPtr = num;
    }
    else if (\u003CModule\u003E.\u003FA0xf690dbd3\u002E_putwc_nolock(ch, f) == ushort.MaxValue && \u003CModule\u003E.ferror(f) != 0)
    {
      *pnumwritten = -1;
    }
    else
    {
      int* numPtr = pnumwritten;
      int num = *numPtr + 1;
      *numPtr = num;
    }
  }

  internal static unsafe void \u003FA0xf690dbd3\u002Ewrite_multi_char(
    [MarshalAs(UnmanagedType.U2)] char ch,
    int num,
    _iobuf* f,
    int* pnumwritten)
  {
    if (num <= 0)
      return;
    do
    {
      --num;
      \u003CModule\u003E.\u003FA0xf690dbd3\u002Ewrite_char(ch, f, pnumwritten);
    }
    while (*pnumwritten != -1 && num > 0);
  }

  internal static unsafe void \u003FA0xf690dbd3\u002Ewrite_string(
    char* @string,
    int len,
    _iobuf* f,
    int* pnumwritten)
  {
    if ((*(int*) ((IntPtr) f + 12) & 64) != 0 && *(int*) ((IntPtr) f + 8) == 0)
    {
      int* numPtr = pnumwritten;
      int num = *numPtr + len;
      *numPtr = num;
    }
    else
    {
      if (len <= 0)
        return;
      do
      {
        --len;
        \u003CModule\u003E.\u003FA0xf690dbd3\u002Ewrite_char(*@string, f, pnumwritten);
        ++@string;
        if (*pnumwritten == -1)
        {
          if (*\u003CModule\u003E._errno() == 42)
            \u003CModule\u003E.\u003FA0xf690dbd3\u002Ewrite_char('?', f, pnumwritten);
          else
            goto label_8;
        }
      }
      while (len > 0);
      goto label_9;
label_8:
      return;
label_9:;
    }
  }

  [PrePrepareMethod]
  internal static unsafe _exception_handling_state_pointers_t* _get_exception_handling_state(
    _exception_handling_state_pointers_t* p)
  {
    return \u003CModule\u003E._get_exception_handling_state_uplevel(p);
  }

  internal static unsafe int _flsbuf_s(int ch, _iobuf* str)
  {
    int num1 = \u003CModule\u003E._fileno(str);
    int num2 = *(int*) ((IntPtr) str + 12);
    if ((num2 & 130) == 0)
    {
      *\u003CModule\u003E._errno() = 9;
      *(int*) ((IntPtr) str + 12) = *(int*) ((IntPtr) str + 12) | 32;
      return -1;
    }
    if ((num2 & 64) != 0)
    {
      *\u003CModule\u003E._errno() = 34;
      *(int*) ((IntPtr) str + 12) = *(int*) ((IntPtr) str + 12) | 32;
      return -1;
    }
    if ((num2 & 1) != 0)
    {
      *(int*) ((IntPtr) str + 4) = 0;
      if ((num2 & 16) != 0)
      {
        _iobuf* iobufPtr = str;
        int num3 = *(int*) ((IntPtr) iobufPtr + 8);
        *(int*) iobufPtr = num3;
        *(int*) ((IntPtr) str + 12) = num2 & -2;
      }
      else
      {
        *(int*) ((IntPtr) str + 12) = num2 | 32;
        return -1;
      }
    }
    int num4 = *(int*) ((IntPtr) str + 12) & -17 | 2;
    *(int*) ((IntPtr) str + 12) = num4;
    *(int*) ((IntPtr) str + 4) = 0;
    int num5 = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if ((num4 & 268) == 0 && ((IntPtr) str != (IntPtr) (^(int&) ref \u003CModule\u003E.__imp__iob + 32) && (IntPtr) str != (IntPtr) (^(int&) ref \u003CModule\u003E.__imp__iob + 64) || \u003CModule\u003E._isatty(num1) == 0))
    {
      *\u003CModule\u003E._errno() = 22;
      \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
      return -1;
    }
    int num6;
    if ((*(int*) ((IntPtr) str + 12) & 264) != 0)
    {
      int num7 = *(int*) ((IntPtr) str + 8);
      num6 = *(int*) str - num7;
      *(int*) str = num7 + 1;
      *(int*) ((IntPtr) str + 4) = *(int*) ((IntPtr) str + 24) - 1;
      if (num6 > 0)
      {
        num5 = \u003CModule\u003E._write(num1, (void*) num7, (uint) num6);
      }
      else
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if ((sbyte) ((int) *(sbyte*) ((num1 == -1 || num1 == -2 ? (IntPtr) (ioinfo*) ^(int&) ref \u003CModule\u003E.__imp___badioinfo : (IntPtr) (ioinfo*) ((num1 & 31) * 36 + *(int*) ((num1 >> 5) * 4 + ^(int&) ref \u003CModule\u003E.__imp___pioinfo))) + 4) & 32) != (sbyte) 0 && \u003CModule\u003E._lseeki64(num1, 0L, 2) == -1L)
        {
          *(int*) ((IntPtr) str + 12) = *(int*) ((IntPtr) str + 12) | 32;
          return -1;
        }
      }
      *(sbyte*) *(int*) ((IntPtr) str + 8) = (sbyte) ch;
    }
    else
    {
      num6 = 1;
      num5 = \u003CModule\u003E._write(num1, (void*) &ch, 1U);
    }
    if (num5 == num6)
      return ch & (int) byte.MaxValue;
    *(int*) ((IntPtr) str + 12) = *(int*) ((IntPtr) str + 12) | 32;
    return -1;
  }

  internal static int _safecrt_cfltcvt(
    _CRT_DOUBLE* arg,
    sbyte* buffer,
    uint _SizeInBytes,
    int type,
    int precision,
    int flags)
  {
    // ISSUE: unable to decompile the method.
  }

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* malloc([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void DeleteCriticalSection([In] _RTL_CRITICAL_SECTION* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void free([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void _CxxThrowException([In] void* obj0, [In] _s__ThrowInfo* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern uint GetLastError();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern uint GetVersion();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void delete([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void CoTaskMemFree([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* @new([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ushort* UfphNativeStrFormat([In] ushort* obj0, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* _getFiberPtrId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void _cexit();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void _amsg_exit([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void Sleep([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern int _callnewh([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe exception* exception\u002E\u007Bctor\u007D(
    [In] exception* obj0,
    [In] exception* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe exception* exception\u002E\u007Bctor\u007D([In] exception* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void exception\u002E\u007Bdtor\u007D([In] exception* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int* _errno();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void _invalid_parameter(
    [In] char* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] uint obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void terminate();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int CoCreateInstance(
    [In] _GUID* obj0,
    [In] IUnknown* obj1,
    [In] uint obj2,
    [In] _GUID* obj3,
    [In] void** obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int CorBindToRuntimeEx(
    [In] char* obj0,
    [In] char* obj1,
    [In] uint obj2,
    [In] _GUID* obj3,
    [In] _GUID* obj4,
    [In] void** obj5);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* _CallSettingFrame(
    [In] void* obj0,
    [In] EHRegistrationNode* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint VirtualQuery(
    [In] void* obj0,
    [In] _MEMORY_BASIC_INFORMATION* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void SetLastError([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe __FnPtr<int ()> GetProcAddress([In] HINSTANCE__* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe HINSTANCE__* GetModuleHandleA([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int _woutput_s([In] _iobuf* obj0, [In] char* obj1, [In] sbyte* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int ferror([In] _iobuf* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int _fileno([In] _iobuf* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int _write([In] int obj0, [In] void* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern int _isatty([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern long _lseeki64([In] int obj0, [In] long obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe sbyte* _itoa([In] int obj0, [In] sbyte* obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int _snprintf([In] sbyte* obj0, [In] uint obj1, [In] sbyte* obj2, __arglist);
}
